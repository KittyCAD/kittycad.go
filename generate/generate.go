//go:build ignore

package main

import (
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/iancoleman/strcase"
)

func main() {
	uri := "https://api.kittycad.io"
	u, err := url.Parse(uri)
	if err != nil {
		fmt.Printf("error parsing url %q: %v\n", uri, err)
		os.Exit(1)
	}

	// Load the open API spec from the URI.
	doc, err := openapi3.NewLoader().LoadFromURI(u)
	if err != nil {
		fmt.Printf("error loading openAPI spec from %q: %v\n", uri, err)
		os.Exit(1)
	}

	// Generate the types.go file.
	generateTypes(doc)

	// Generate the responses.go file.
	generateResponses(doc)

	// Generate the paths.go file.
	generatePaths(doc)
}

// Generate the types.go file.
func generateTypes(doc *openapi3.T) {
	f := openGeneratedFile("types.go")
	defer f.Close()

	// Iterate over all the schema components in the spec and write the types.
	for name, s := range doc.Components.Schemas {
		if s.Ref != "" {
			fmt.Printf("[WARN] TODO: skipping type for %q, since it is a reference\n", name)
			continue
		}

		writeSchemaType(f, name, s.Value)
	}
}

// Generate the responses.go file.
func generateResponses(doc *openapi3.T) {
	f := openGeneratedFile("responses.go")
	defer f.Close()

	// Iterate over all the responses in the spec and write the types.
	for name, r := range doc.Components.Responses {
		if r.Ref != "" {
			fmt.Printf("[WARN] TODO: skipping response for %q, since it is a reference\n", name)
			continue
		}

		writeResponseType(f, name, r.Value)
	}
}

// Generate the paths.go file.
func generatePaths(doc *openapi3.T) {
	f := openGeneratedFile("paths.go")
	defer f.Close()

	// Iterate over all the paths in the spec and write the types.
	for path, p := range doc.Paths {
		if p.Ref != "" {
			fmt.Printf("[WARN] TODO: skipping path for %q, since it is a reference\n", path)
			continue
		}

		writePath(f, path, p)
	}
}

func openGeneratedFile(filename string) *os.File {
	// Get the current working directory.
	cwd, err := os.Getwd()
	if err != nil {
		fmt.Printf("error getting current working directory: %v\n", err)
		os.Exit(1)
	}

	p := filepath.Join(cwd, filename)

	// Create the types.go file.
	// Open the file for writing.
	f, err := os.OpenFile(p, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		fmt.Printf("error creating %q: %v\n", p, err)
		os.Exit(1)
	}

	// Add the header to the package.
	fmt.Fprintf(f, "// Code generated by `%s`. DO NOT EDIT.\n\n", filepath.Base(os.Args[0]))
	fmt.Fprintln(f, "package kittycad")
	fmt.Fprintln(f, "")

	return f
}

// printProperty converts an object's property name to a valid Go identifier.
func printProperty(p string) string {
	c := strcase.ToCamel(p)
	if c == "Id" {
		c = "ID"
	} else if c == "IpAddress" {
		c = "IPAddress"
	} else if c == "UserId" {
		c = "UserID"
	} else if c == "CpuPlatform" {
		c = "CPUPlatform"
	}
	return c
}

// printType converts a schema type to a valid Go type.
func printType(r *openapi3.SchemaRef) string {
	s := r.Value
	t := s.Type
	if t == "string" {
		reference := getReferenceSchema(r)
		if reference != "" {
			return reference
		}

		return formatStringType(s)
	} else if t == "integer" {
		return "int"
	} else if t == "number" {
		return "float64"
	} else if t == "boolean" {
		return "bool"
	} else if t == "array" {
		return "[]"
	} else if t == "object" {
		return "struct {"
	}
	// return a TODO;
	return "TODO"
}

// writePath writes the given path as an http request to the given file.
func writePath(f *os.File, path string, p *openapi3.PathItem) {
	if p.Get != nil {
		writeMethod(f, http.MethodGet, path, p.Get)
	}

	if p.Post != nil {
		writeMethod(f, http.MethodPost, path, p.Post)
	}

	if p.Put != nil {
		writeMethod(f, http.MethodPut, path, p.Put)
	}

	if p.Delete != nil {
		writeMethod(f, http.MethodDelete, path, p.Delete)
	}

	if p.Patch != nil {
		writeMethod(f, http.MethodPatch, path, p.Patch)
	}

	if p.Head != nil {
		writeMethod(f, http.MethodHead, path, p.Head)
	}

	if p.Options != nil {
		writeMethod(f, http.MethodOptions, path, p.Options)
	}
}

func writeMethod(f *os.File, method string, path string, o *openapi3.Operation) {
	respType := getSuccessResponseType(o)
	fnName := strcase.ToCamel(o.OperationID)

	// Parse the parameters.
	params := map[string]*openapi3.Parameter{}
	paramsString := ""
	for _, p := range o.Parameters {
		if p.Ref != "" {
			fmt.Printf("[WARN] TODO: skipping parameter for %q, since it is a reference\n", p.Value.Name)
			continue
		}

		params[p.Value.Name] = p.Value
		paramsString += fmt.Sprintf("%s %s, ", strcase.ToLowerCamel(p.Value.Name), printType(p.Value.Schema))
	}

	fmt.Printf("writing method %q for path %q\n", method, path)

	// Write the description for the method.
	fmt.Fprintf(f, "// %s: %s\n", fnName, o.Summary)
	if o.Description != "" {
		fmt.Fprintln(f, "//")
		fmt.Fprintf(f, "// %s\n", o.Description)
	}
	if len(params) > 0 {
		fmt.Fprintf(f, "//\n// Parameters:\n")
		for name, t := range params {
			if t.Description != "" {
				fmt.Fprintf(f, "//\t`%s`: %s\n", strcase.ToLowerCamel(name), t.Description)
			}
		}
	}

	// Write the method.
	fmt.Fprintf(f, "func (c *Client) %s(%s) (*%s, error) {\n",
		fnName,
		paramsString,
		respType)

	// Create the url.
	fmt.Fprintln(f, "// Create the url.")
	fmt.Fprintf(f, "path := %q\n", cleanPath(path))
	fmt.Fprintln(f, "uri := resolveRelative(c.server, path)")

	// Create the request.
	fmt.Fprintln(f, "// Create the request.")
	fmt.Fprintf(f, "req, err := http.NewRequest(%q, uri, nil)\n", method)
	fmt.Fprintln(f, "if err != nil {")
	fmt.Fprintln(f, `return nil, fmt.Errorf("error creating request: %v", err)`)
	fmt.Fprintln(f, "}")

	// Add the parameters to the url.
	if len(params) > 0 {
		fmt.Fprintln(f, "// Add the parameters to the url.")
		fmt.Fprintln(f, "if err := expandURL(req.URL, map[string]string{")
		for name := range params {
			fmt.Fprintf(f, "	%q: string(%s),\n", strcase.ToLowerCamel(name), strcase.ToLowerCamel(name))
		}
		fmt.Fprintln(f, "}); err != nil {")
		fmt.Fprintln(f, `return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)`)
		fmt.Fprintln(f, "}")
	}

	// Send the request.
	fmt.Fprintln(f, "// Send the request.")
	fmt.Fprintln(f, "resp, err := c.client.Do(req)")
	fmt.Fprintln(f, "if err != nil {")
	fmt.Fprintln(f, `return nil, fmt.Errorf("error sending request: %v", err)`)
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f, "defer resp.Body.Close()")

	// Check the response if there were any errors.
	fmt.Fprintln(f, "// Check the response.")
	fmt.Fprintln(f, "if err := checkResponse(resp); err != nil {")
	fmt.Fprintln(f, "return nil, err")
	fmt.Fprintln(f, "}")

	// Decode the body from the response.
	fmt.Fprintln(f, "// Decode the body from the response.")
	fmt.Fprintln(f, "if resp.Body == nil {")
	fmt.Fprintln(f, `return nil, errors.New("request returned an empty body in the response")`)
	fmt.Fprintln(f, "}")

	fmt.Fprintf(f, "var body %s\n", respType)
	fmt.Fprintln(f, "if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {")
	fmt.Fprintln(f, `return nil, fmt.Errorf("error decoding response body: %v", err)`)
	fmt.Fprintln(f, "}")

	// Return the response.
	fmt.Fprintln(f, "// Return the response.")
	fmt.Fprintln(f, "return &body, nil")

	// Close the method.
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f, "")
}

// cleanPath returns the path as a function we can use for a go template.
func cleanPath(path string) string {
	path = strings.Replace(path, "{", "{{.", -1)
	return strings.Replace(path, "}", "}}", -1)
}

func getSuccessResponseType(o *openapi3.Operation) string {
	for name, response := range o.Responses {
		statusCode, err := strconv.Atoi(name)
		if err != nil {
			fmt.Printf("error converting %q to an integer: %v\n", name, err)
			os.Exit(1)
		}

		if statusCode < 200 || statusCode >= 300 {
			// Continue early, we just want the successful response.
			continue
		}

		if response.Ref != "" {
			fmt.Printf("[WARN] TODO: skipping response for %q, since it is a reference: %q\n", name, response.Ref)
			continue
		}

		for _, content := range response.Value.Content {
			if content.Schema.Ref != "" {
				return getReferenceSchema(content.Schema)
			}

			return fmt.Sprintf("%sResponse", strcase.ToCamel(o.OperationID))
		}
	}

	return ""
}

// writeSchemaType writes a type definition for the given schema.
func writeSchemaType(f *os.File, name string, s *openapi3.Schema) {
	otype := s.Type
	fmt.Printf("writing type for schema %q -> %s\n", name, otype)

	if len(s.Enum) == 0 {
		// Write the type description.
		writeSchemaTypeDescription(name, s, f)
	}

	if otype == "string" {
		// If this is an enum, write the enum type.
		if len(s.Enum) > 0 {
			// Write the type description.
			writeSchemaTypeDescription(makeSingular(name), s, f)

			// Write the enum type.
			fmt.Fprintf(f, "type %s string\n", makeSingular(name))
			// Define the enum values.
			fmt.Fprintf(f, "const (\n")
			for _, v := range s.Enum {
				// Most likely, the enum values are strings.
				enum, ok := v.(string)
				if !ok {
					fmt.Printf("[WARN] TODO: enum value is not a string for %q -> %#v\n", name, v)
					continue
				}
				// Write the description of the constant.
				fmt.Fprintf(f, "// %s represents the %s `%q`.\n", strcase.ToCamel(fmt.Sprintf("%s_%s", makeSingular(name), enum)), makeSingular(name), enum)
				fmt.Fprintf(f, "\t%s %s = %q\n", strcase.ToCamel(fmt.Sprintf("%s_%s", makeSingular(name), enum)), makeSingular(name), enum)
			}
			// Close the enum values.
			fmt.Fprintf(f, ")\n")

			// Make the enum a collection of the values.
			// Add a description.
			fmt.Fprintf(f, "// %s is the collection of all %s values.\n", makePlural(name), makeSingular(name))
			fmt.Fprintf(f, "var %s = []%s{\n", makePlural(name), makeSingular(name))
			for _, v := range s.Enum {
				// Most likely, the enum values are strings.
				enum, ok := v.(string)
				if !ok {
					fmt.Printf("[WARN] TODO: enum value is not a string for %q -> %#v\n", name, v)
					continue
				}
				fmt.Fprintf(f, "\t%s,\n", strcase.ToCamel(fmt.Sprintf("%s_%s", makeSingular(name), enum)))
			}
			// Close the enum values.
			fmt.Fprintf(f, "}\n")
		} else {
			fmt.Fprintf(f, "type %s string\n", name)
		}
	} else if otype == "integer" {
		fmt.Fprintf(f, "type %s int\n", name)
	} else if otype == "number" {
		fmt.Fprintf(f, "type %s float64\n", name)
	} else if otype == "boolean" {
		fmt.Fprintf(f, "type %s bool\n", name)
	} else if otype == "array" {
		fmt.Fprintf(f, "type %s []%s\n", name, s.Items.Value.Type)
	} else if otype == "object" {
		recursive := false
		fmt.Fprintf(f, "type %s struct {\n", name)
		for k, v := range s.Properties {
			// Check if we need to generate a type for this type.
			typeName := printType(v)

			if isLocalEnum(v) {
				recursive = true
				typeName = fmt.Sprintf("%s%s", name, printProperty(k))
			}

			if v.Value.Description != "" {
				fmt.Fprintf(f, "\t// %s is %s\n", printProperty(k), toLowerFirstLetter(v.Value.Description))
			}
			fmt.Fprintf(f, "\t%s %s `json:\"%s,omitempty\" yaml:\"%s,omitempty\"`\n", printProperty(k), typeName, k, k)
		}
		fmt.Fprintf(f, "}\n")

		if recursive {
			// Add a newline at the end of the type.
			fmt.Fprintln(f, "")

			// Iterate over the properties and write the types, if we need to.
			for k, v := range s.Properties {
				if isLocalEnum(v) {
					writeSchemaType(f, fmt.Sprintf("%s%s", name, printProperty(k)), v.Value)
				}
			}
		}
	} else {
		fmt.Printf("[WARN] TODO: skipping type for %q, since it is a %q\n", name, otype)
	}

	// Add a newline at the end of the type.
	fmt.Fprintln(f, "")
}

func isLocalEnum(v *openapi3.SchemaRef) bool {
	return v.Ref == "" && v.Value.Type == "string" && len(v.Value.Enum) > 0
}

// formatStringType converts a string schema to a valid Go type.
func formatStringType(t *openapi3.Schema) string {
	if t.Format == "date-time" {
		return "time.Time"
	} else if t.Format == "date" {
		return "time.Time"
	} else if t.Format == "time" {
		return "time.Time"
	} else if t.Format == "email" {
		return "string"
	} else if t.Format == "hostname" {
		return "string"
	} else if t.Format == "ipv4" {
		return "string"
	} else if t.Format == "ipv6" {
		return "string"
	} else if t.Format == "uri" {
		return "string"
	} else if t.Format == "uuid" {
		return "string"
	} else if t.Format == "uuid3" {
		return "string"
	}

	return "string"
}

// toLowerFirstLetter returns the given string with the first letter converted to lower case.
func toLowerFirstLetter(str string) string {
	for i, v := range str {
		return string(unicode.ToLower(v)) + str[i+1:]
	}
	return ""
}

// makeSingular returns the given string but singular.
func makeSingular(s string) string {
	if strings.HasSuffix(s, "Status") {
		return s
	}
	return strings.TrimSuffix(s, "s")
}

// makePlural returns the given string but plural.
func makePlural(s string) string {
	singular := makeSingular(s)
	if strings.HasSuffix(singular, "s") {
		return singular + "es"
	}

	return singular + "s"
}

// writeSchemaTypeDescription writes the description of the given type.
func writeSchemaTypeDescription(name string, s *openapi3.Schema, f *os.File) {
	if s.Description != "" {
		fmt.Fprintf(f, "// %s is %s\n", name, toLowerFirstLetter(s.Description))
	} else {
		fmt.Fprintf(f, "// %s is the type definition for a %s.\n", name, name)
	}
}

// writeReponseTypeDescription writes the description of the given type.
func writeResponseTypeDescription(name string, r *openapi3.Response, f *os.File) {
	if r.Description != nil {
		fmt.Fprintf(f, "// %s is the response given when %s\n", name, toLowerFirstLetter(*r.Description))
	} else {
		fmt.Fprintf(f, "// %s is the type definition for a %s response.\n", name, name)
	}
}

func getReferenceSchema(v *openapi3.SchemaRef) string {
	if v.Ref != "" {
		ref := strings.TrimPrefix(v.Ref, "#/components/schemas/")
		if len(v.Value.Enum) > 0 {
			return makeSingular(ref)
		}

		return ref
	}

	return ""
}

// writeResponseType writes a type definition for the given response.
func writeResponseType(f *os.File, name string, r *openapi3.Response) {

	// Write the type definition.
	for k, v := range r.Content {
		fmt.Printf("writing type for response %q -> `%s`\n", name, k)

		name := fmt.Sprintf("%sResponse", name)

		// Write the type description.
		writeResponseTypeDescription(name, r, f)

		// Print the type definition.
		s := v.Schema
		if s.Ref != "" {
			fmt.Fprintf(f, "type %s %s\n", name, getReferenceSchema(s))
			continue
		}

		writeSchemaType(f, name, s.Value)
	}
}
