// Code generated by `generate`. DO NOT EDIT.

package kittycad

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/gorilla/schema"
	"github.com/gorilla/websocket"
)

// GetSchema: Get OpenAPI schema.
func (s *MetaService) GetSchema() error {
	// Create the url.
	path := "/"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetIpinfo: Get ip address information.
func (s *MetaService) GetIpinfo() (*IpAddrInfo, error) {
	// Create the url.
	path := "/_meta/ipinfo"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded IpAddrInfo
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateTextToCad: Generate a CAD model from text.
// Because our source of truth for the resulting model is a STEP file, you will always have STEP file contents when you list your generated parts. Any other formats you request here will also be returned when you list your generated parts.
//
// This operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// One thing to note, if you hit the cache, this endpoint will return right away. So you only have to wait if the status is not `Completed` or `Failed`.
//
// Parameters
//
//   - `outputFormat`: The valid types of output file formats.
//   - `kcl`
//   - `body`: Body for generating parts from text.
func (s *MlService) CreateTextToCad(outputFormat FileExportFormat, kcl bool, body TextToCadCreateBody) (*TextToCad, error) {
	// Create the url.
	path := "/ai/text-to-cad/{{.output_format}}"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_format": string(outputFormat),
		"kcl":           strconv.FormatBool(kcl),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded TextToCad
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetMetrics: Get API call metrics.
// This endpoint requires authentication by a Zoo employee. The API calls are grouped by the parameter passed.
//
// Parameters
//
//   - `groupBy`: The field of an API call to group by.
func (s *APICallService) GetMetrics(groupBy APICallQueryGroupBy) (*[]APICallQueryGroup, error) {
	// Create the url.
	path := "/api-call-metrics"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"group_by": string(groupBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []APICallQueryGroup
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// List: List API calls.
// This endpoint requires authentication by a Zoo employee. The API calls are returned in order of creation, with the most recently created API calls first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *APICallService) List(limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/api-calls"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Get: Get details of an API call.
// This endpoint requires authentication by any Zoo user. It returns details of the requested API call for the user.
//
// If the user is not authenticated to view the specified API call, then it is not returned.
//
// Only Zoo employees can view API calls for other users.
//
// Parameters
//
//   - `id`
func (s *APICallService) Get(id UUID) (*APICallWithPrice, error) {
	// Create the url.
	path := "/api-calls/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPrice
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GithubCallback: Listen for callbacks to GitHub app authentication.
// This is different than OAuth 2.0 authentication for users. This endpoint grants access for Zoo to access user's repos.
//
// The user doesn't need Zoo OAuth authorization for this endpoint, this is purely for the GitHub permissions to access repos.
//
// Parameters
//
//   - `body`
func (s *AppService) GithubCallback(body any) error {
	// Create the url.
	path := "/apps/github/callback"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GithubConsent: Get the consent URL for GitHub app authentication.
// This is different than OAuth 2.0 authentication for users. This endpoint grants access for Zoo to access user's repos.
//
// The user doesn't need Zoo OAuth authorization for this endpoint, this is purely for the GitHub permissions to access repos.
func (s *AppService) GithubConsent() (*AppClientInfo, error) {
	// Create the url.
	path := "/apps/github/consent"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded AppClientInfo
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GithubWebhook: Listen for GitHub webhooks.
// These come from the GitHub app.
//
// Parameters
//
//   - `body`
func (s *AppService) GithubWebhook(body []byte) error {
	// Create the url.
	path := "/apps/github/webhook"
	targetURL := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ListAsyncOperations: List async operations.
// For async file conversion operations, this endpoint does not return the contents of converted files (`output`). To get the contents use the `/async/operations/{id}` endpoint.
//
// This endpoint requires authentication by a Zoo employee.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
//
//   - `status`: The status of an async API call.
func (s *APICallService) ListAsyncOperations(limit int, pageToken string, sortBy CreatedAtSortMode, status APICallStatus) (*AsyncAPICallResultsPage, error) {
	// Create the url.
	path := "/async/operations"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
		"status":     string(status),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded AsyncAPICallResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetAsyncOperation: Get an async operation.
// Get the status and output of an async operation.
//
// This endpoint requires authentication by any Zoo user. It returns details of the requested async operation for the user.
//
// If the user is not authenticated to view the specified async operation, then it is not returned.
//
// Only Zoo employees with the proper access can view async operations for other users.
//
// Parameters
//
//   - `id`
func (s *APICallService) GetAsyncOperation(id UUID) (*any, error) {
	// Create the url.
	path := "/async/operations/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded any
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// AuthAPIKey: Authenticate using an api-key. This is disabled on production but can be used in dev to login without email magic.
// This returns a session token.
func (s *HiddenService) AuthAPIKey() (*AuthAPIKeyResponse, error) {
	// Create the url.
	path := "/auth/api-key"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded AuthAPIKeyResponse
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// AuthEmail: Create an email verification request for a user.
// Parameters
//
//   - `body`: The body of the form for email authentication.
func (s *HiddenService) AuthEmail(body EmailAuthenticationForm) (*VerificationTokenResponse, error) {
	// Create the url.
	path := "/auth/email"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded VerificationTokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// AuthEmailCallback: Listen for callbacks for email authentication for users.
// Parameters
//
//   - `callbackUrl`
//   - `email`
//   - `token`
func (s *HiddenService) AuthEmailCallback(callbackUrl URL, email string, token string) error {
	// Create the url.
	path := "/auth/email/callback"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"callback_url": callbackUrl.String(),
		"email":        email,
		"token":        token,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetAuthSamlByOrg: GET /auth/saml/{org_id}
// Redirects the browser straight to the orgâ€™s SAML IdP.
//
// Parameters
//
//   - `orgId`: A UUID usually v4 or v7
//   - `callbackUrl`
func (s *HiddenService) GetAuthSamlByOrg(orgId UUID, callbackUrl URL) error {
	// Create the url.
	path := "/auth/saml/org/{{.org_id}}/login"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"org_id":       orgId.String(),
		"callback_url": callbackUrl.String(),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetAuthSaml: Get a redirect straight to the SAML IdP.
// The UI uses this to avoid having to ask the API anything about the IdP. It already knows the SAML IdP ID from the path, so it can just link to this path and rely on the API to redirect to the actual IdP.
//
// Parameters
//
//   - `providerId`: A UUID usually v4 or v7
//   - `callbackUrl`
func (s *HiddenService) GetAuthSaml(providerId UUID, callbackUrl URL) error {
	// Create the url.
	path := "/auth/saml/provider/{{.provider_id}}/login"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider_id":  providerId.String(),
		"callback_url": callbackUrl.String(),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// PostAuthSaml: Authenticate a user via SAML
// Parameters
//
//   - `providerId`: A UUID usually v4 or v7
//   - `body`
func (s *HiddenService) PostAuthSaml(providerId UUID, body []byte) error {
	// Create the url.
	path := "/auth/saml/provider/{{.provider_id}}/login"
	targetURL := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider_id": providerId.String(),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// CommunitySso: Authorize an inbound auth request from our Community page.
// Parameters
//
//   - `sig`
//   - `sso`
func (s *MetaService) CommunitySso(sig string, sso string) error {
	// Create the url.
	path := "/community/sso"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sig": sig,
		"sso": sso,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// CreateDebugUploads: Uploads files to public blob storage for debugging purposes.
// Do NOT send files here that you don't want to be public.
//
// Parameters
//
//   - `body`
func (s *MetaService) CreateDebugUploads(body *bytes.Buffer) (*[]URL, error) {
	// Create the url.
	path := "/debug/uploads"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, body)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "multipart/form-data")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []URL
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateEvent: Creates an internal telemetry event.
// We collect anonymous telemetry data for improving our product.
//
// Parameters
//
//   - `body`: Telemetry data we are collecting
func (s *MetaService) CreateEvent(body *bytes.Buffer) error {
	// Create the url.
	path := "/events"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, body)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "multipart/form-data")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// CreateCenterOfMass: Get CAD file center of mass.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
//
// This endpoint returns the cartesian coordinate in world space measure units.
//
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
//
// Get the center of mass of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
//
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `outputUnit`: The valid types of length units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateCenterOfMass(outputUnit UnitLength, srcFormat FileImportFormat, body []byte) (*FileCenterOfMass, error) {
	// Create the url.
	path := "/file/center-of-mass"
	targetURL := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_unit": string(outputUnit),
		"src_format":  string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileCenterOfMass
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateConversionOptions: Convert CAD file from one format to another.
// This takes a HTTP multipart body with these fields in any order:
//
//   - The input and output format options (as JSON), name is 'body'.  - The files to convert, in raw binary. Must supply filenames.
//
// This starts a conversion job and returns the `id` of the operation. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `body`: Describes the file to convert (src) and what it should be converted into (output).
func (s *FileService) CreateConversionOptions(body *bytes.Buffer) (*FileConversion, error) {
	// Create the url.
	path := "/file/conversion"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, body)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "multipart/form-data")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateConversion: Convert CAD file with defaults.
// If you wish to specify the conversion options, use the `/file/conversion` endpoint instead.
//
// Convert a CAD file from one format to another. If the file being converted is larger than 25MB, it will be performed asynchronously.
//
// If the conversion is performed synchronously, the contents of the converted file (`output`) will be returned as a base64 encoded string.
//
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `outputFormat`: The valid types of output file formats.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateConversion(outputFormat FileExportFormat, srcFormat FileImportFormat, body []byte) (*FileConversion, error) {
	// Create the url.
	path := "/file/conversion/{{.src_format}}/{{.output_format}}"
	targetURL := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_format": string(outputFormat),
		"src_format":    string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateDensity: Get CAD file density.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
//
// This endpoint assumes if you are giving a material mass in a specific mass units, we return a density in mass unit per cubic measure unit.
//
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
//
// Get the density of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
//
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `materialMass`
//   - `materialMassUnit`: The valid types of mass units.
//   - `outputUnit`: The valid types for density units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateDensity(materialMass float64, materialMassUnit UnitMas, outputUnit UnitDensity, srcFormat FileImportFormat, body []byte) (*FileDensity, error) {
	// Create the url.
	path := "/file/density"
	targetURL := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"material_mass":      fmt.Sprintf("%f", materialMass),
		"material_mass_unit": string(materialMassUnit),
		"output_unit":        string(outputUnit),
		"src_format":         string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileDensity
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateFileExecution: Execute a Zoo program in a specific language.
// Parameters
//
//   - `lang`: The language code is written in.
//
//     <details><summary>JSON schema</summary>
//
//     ```json { "description": "The language code is written in.", "oneOf": [ { "description": "The `go` programming language.", "type": "string", "enum": [ "go" ] }, { "description": "The `python` programming language.", "type": "string", "enum": [ "python" ] }, { "description": "The `node` programming language.", "type": "string", "enum": [ "node" ] } ] } ``` </details>
//
//   - `output`
//
//   - `body`
func (s *ExecutorService) CreateFileExecution(lang CodeLanguage, output string, body []byte) (*CodeOutput, error) {
	// Create the url.
	path := "/file/execute/{{.lang}}"
	targetURL := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"lang":   string(lang),
		"output": output,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CodeOutput
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateMass: Get CAD file mass.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
//
// This endpoint assumes if you are giving a material density in a specific mass unit per cubic measure unit, we return a mass in mass units. The same mass units as passed in the material density.
//
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
//
// Get the mass of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
//
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `materialDensity`
//   - `materialDensityUnit`: The valid types for density units.
//   - `outputUnit`: The valid types of mass units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateMass(materialDensity float64, materialDensityUnit UnitDensity, outputUnit UnitMas, srcFormat FileImportFormat, body []byte) (*FileMass, error) {
	// Create the url.
	path := "/file/mass"
	targetURL := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"material_density":      fmt.Sprintf("%f", materialDensity),
		"material_density_unit": string(materialDensityUnit),
		"output_unit":           string(outputUnit),
		"src_format":            string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileMass
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateSurfaceArea: Get CAD file surface area.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
//
// This endpoint returns the square measure units.
//
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
//
// Get the surface area of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
//
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `outputUnit`: The valid types of area units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateSurfaceArea(outputUnit UnitArea, srcFormat FileImportFormat, body []byte) (*FileSurfaceArea, error) {
	// Create the url.
	path := "/file/surface-area"
	targetURL := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_unit": string(outputUnit),
		"src_format":  string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileSurfaceArea
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateVolume: Get CAD file volume.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
//
// This endpoint returns the cubic measure units.
//
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
//
// Get the volume of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
//
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `outputUnit`: The valid types of volume units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateVolume(outputUnit UnitVolume, srcFormat FileImportFormat, body []byte) (*FileVolume, error) {
	// Create the url.
	path := "/file/volume"
	targetURL := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_unit": string(outputUnit),
		"src_format":  string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileVolume
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// InternalGetAPITokenForDiscordUser: Get an API token for a user by their discord id.
// This endpoint allows us to run API calls from our discord bot on behalf of a user. The user must have a discord account linked to their Zoo Account via oauth2 for this to work.
//
// You must be a Zoo admin to use this endpoint.
//
// Parameters
//
//   - `discordId`
func (s *MetaService) InternalGetAPITokenForDiscordUser(discordId string) (*APIToken, error) {
	// Create the url.
	path := "/internal/discord/api-token/{{.discord_id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"discord_id": discordId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APIToken
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Logout: This endpoint removes the session cookie for a user.
// This is used in logout scenarios.
func (s *HiddenService) Logout() error {
	// Create the url.
	path := "/logout"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ListPrompts: List all ML prompts.
// For text-to-cad prompts, this will always return the STEP file contents as well as the format the user originally requested.
//
// This endpoint requires authentication by a Zoo employee.
//
// The ML prompts are returned in order of creation, with the most recently created ML prompts first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *MlService) ListPrompts(limit int, pageToken string, sortBy CreatedAtSortMode) (*MlPromptResponseResultsPage, error) {
	// Create the url.
	path := "/ml-prompts"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded MlPromptResponseResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetPrompt: Get a ML prompt.
// This endpoint requires authentication by a Zoo employee.
//
// Parameters
//
//   - `id`
func (s *MlService) GetPrompt(id UUID) (*MlPromptResponse, error) {
	// Create the url.
	path := "/ml-prompts/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded MlPromptResponse
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListConversationsForUser: List conversations
// This endpoint requires authentication by any Zoo user. It returns the conversations for the authenticated user.
//
// The conversations are returned in order of creation, with the most recently created conversations first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *MlService) ListConversationsForUser(limit int, pageToken string, sortBy CreatedAtSortMode) (*ConversationResultsPage, error) {
	// Create the url.
	path := "/ml/conversations"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ConversationResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateProprietaryToKcl: Converts a proprietary CAD format to KCL.
// This endpoint is used to convert a proprietary CAD format to KCL. The file passed MUST have feature tree data.
//
// A STEP file does not have feature tree data, so it will not work. A sldprt file does have feature tree data, so it will work.
//
// This endpoint is designed to work with any native proprietary CAD format, for example: - SolidWorks (.sldprt) - Creo (.prt) - Catia (.catpart) - NX (.prt) - Fusion 360 (.f3d)
//
// This endpoint is deterministic, it preserves the original design intent by using the feature tree data. This endpoint does not use any machine learning or AI.
//
// This endpoint is currently in beta, and is only available to users with access to the feature. Please contact support if you are interested in getting access.
//
// This endpoint might have limitations and bugs, please report any issues you encounter. It will be improved over time.
//
// Input filepaths will be normalized and re-canonicalized to be under the current working directory -- so returned paths may differ from provided paths, and care must be taken when handling user provided paths.
//
// Parameters
//
//   - `codeOption`: `CodeOption`
//
//     <details><summary>JSON schema</summary>
//
//     ```json { "type": "string", "enum": [ "parse", "mock_execute", "execute" ] } ``` </details>
//
//   - `body`
func (s *MlService) CreateProprietaryToKcl(codeOption CodeOption, body *bytes.Buffer) (*KclModel, error) {
	// Create the url.
	path := "/ml/convert/proprietary-to-kcl"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, body)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "multipart/form-data")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"code_option": string(codeOption),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded KclModel
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateCustomModel: Create a custom ML model that is backed by one or more org datasets.
// Dataset readiness is enforced via `OrgDatasetFileConversion::status_counts_for_datasets`: - At least one conversion must have status `success`. - No conversions may remain in `queued`. If even a single file is still queued the dataset is treated as â€œnot ready for training.â€ - A dataset consisting only of `canceled` or `error_*` entries is rejected because thereâ€™s nothing usable.
//
// Parameters
//
//   - `body`: Body for creating a custom ML model.
func (s *MlService) CreateCustomModel(body CreateCustomModel) (*CustomModel, error) {
	// Create the url.
	path := "/ml/custom/models"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomModel
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetCustomModel: Retrieve the details of a single custom ML model so long as it belongs to the callerâ€™s organization.
// Parameters
//
//   - `id`: A UUID usually v4 or v7
func (s *MlService) GetCustomModel(id UUID) (*CustomModel, error) {
	// Create the url.
	path := "/ml/custom/models/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomModel
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateCustomModel: Update mutable metadata (name, system prompt) for a custom ML model owned by the caller's organization.
// Parameters
//
//   - `id`: A UUID usually v4 or v7
//   - `body`: Body for updating a custom ML model.
func (s *MlService) UpdateCustomModel(id UUID, body UpdateCustomModel) (*CustomModel, error) {
	// Create the url.
	path := "/ml/custom/models/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomModel
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListOrgDatasetsForModel: List the org datasets that are currently attached to a custom ML model owned by the callerâ€™s organization.
// Parameters
//
//   - `id`: A UUID usually v4 or v7
func (s *MlService) ListOrgDatasetsForModel(id UUID) (*[]OrgDataset, error) {
	// Create the url.
	path := "/ml/custom/models/{{.id}}/datasets"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []OrgDataset
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateKclCodeCompletions: Generate code completions for KCL.
// Parameters
//
//   - `body`: A request to generate KCL code completions.
func (s *MlService) CreateKclCodeCompletions(body KclCodeCompletionRequest) (*KclCodeCompletionResponse, error) {
	// Create the url.
	path := "/ml/kcl/completions"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded KclCodeCompletionResponse
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateTextToCadIteration: Iterate on a CAD model with a prompt.
// Even if you give specific ranges to edit, the model might change more than just those in order to make the changes you requested without breaking the code.
//
// You always get the whole code back, even if you only changed a small part of it.
//
// This operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// This endpoint will soon be deprecated in favor of the `/ml/text-to-cad/multi-file/iteration` endpoint. In that the endpoint path will remain but it will have the same behavior as `ml/text-to-cad/multi-file/iteration`.
//
// Parameters
//
//   - `body`: Body for generating parts from text.
func (s *MlService) CreateTextToCadIteration(body TextToCadIterationBody) (*TextToCadIteration, error) {
	// Create the url.
	path := "/ml/text-to-cad/iteration"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded TextToCadIteration
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateTextToCadMultiFileIteration: Iterate on a multi-file CAD model with a prompt.
// This endpoint can iterate on multi-file projects.
//
// Even if you give specific ranges to edit, the model might change more than just those in order to make the changes you requested without breaking the code.
//
// You always get the whole code back, even if you only changed a small part of it. This endpoint will always return all the code back, including files that were not changed. If your original source code imported a stl/gltf/step/etc file, the output will not include that file since the model will never change non-kcl files. The endpoint will only return the kcl files that were changed.
//
// This operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Input filepaths will be normalized and re-canonicalized to be under the current working directory -- so returned paths may differ from provided paths, and care must be taken when handling user provided paths.
//
// Parameters
//
//   - `body`: Body for iterating on models from text prompts.
func (s *MlService) CreateTextToCadMultiFileIteration(body *bytes.Buffer) (*TextToCadMultiFileIteration, error) {
	// Create the url.
	path := "/ml/text-to-cad/multi-file/iteration"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, body)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "multipart/form-data")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded TextToCadMultiFileIteration
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeviceAuthRequest: Start an OAuth 2.0 Device Authorization Grant.
// This endpoint is designed to be accessed from an *unauthenticated* API client. It generates and records a `device_code` and `user_code` which must be verified and confirmed prior to a token being granted.
//
// Parameters
//
//   - `body`: The request parameters for the OAuth 2.0 Device Authorization Grant flow.
func (s *Oauth2Service) DeviceAuthRequest(body DeviceAuthRequestForm) error {
	// Create the url.
	path := "/oauth2/device/auth"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as a form.
	form := url.Values{}
	encoder := schema.NewEncoder()
	err := encoder.Encode(body, form)
	if err != nil {
		return fmt.Errorf("encoding form body request failed: %v", err)
	}
	b := strings.NewReader(form.Encode())

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// DeviceAuthConfirm: Confirm an OAuth 2.0 Device Authorization Grant.
// This endpoint is designed to be accessed by the user agent (browser), not the client requesting the token. So we do not actually return the token here; it will be returned in response to the poll on `/oauth2/device/token`.
//
// Parameters
//
//   - `body`: The request parameters to confirm the `user_code` for the OAuth 2.0 Device Authorization Grant.
func (s *Oauth2Service) DeviceAuthConfirm(body DeviceAuthConfirmParams) error {
	// Create the url.
	path := "/oauth2/device/confirm"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// DeviceAccessToken: Request a device access token.
// This endpoint should be polled by the client until the user code is verified and the grant is confirmed.
//
// Parameters
//
//   - `body`: The form for a device access token request.
func (s *Oauth2Service) DeviceAccessToken(body DeviceAccessTokenRequestForm) error {
	// Create the url.
	path := "/oauth2/device/token"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as a form.
	form := url.Values{}
	encoder := schema.NewEncoder()
	err := encoder.Encode(body, form)
	if err != nil {
		return fmt.Errorf("encoding form body request failed: %v", err)
	}
	b := strings.NewReader(form.Encode())

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// DeviceAuthVerify: Verify an OAuth 2.0 Device Authorization Grant.
// This endpoint should be accessed in a full user agent (e.g., a browser). If the user is not logged in, we redirect them to the login page and use the `callback_url` parameter to get them to the UI verification form upon logging in. If they are logged in, we redirect them to the UI verification form on the website.
//
// Parameters
//
//   - `appName`
//   - `userCode`
func (s *Oauth2Service) DeviceAuthVerify(appName string, userCode string) error {
	// Create the url.
	path := "/oauth2/device/verify"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"app_name":  appName,
		"user_code": userCode,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ProviderCallback: Listen for callbacks for the OAuth 2.0 provider.
// Parameters
//
//   - `provider`: An account provider.
//   - `code`
//   - `idToken`
//   - `state`
//   - `user`
func (s *Oauth2Service) ProviderCallback(provider AccountProvider, code string, idToken string, state string, user string) error {
	// Create the url.
	path := "/oauth2/provider/{{.provider}}/callback"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider": string(provider),
		"code":     code,
		"id_token": idToken,
		"state":    state,
		"user":     user,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ProviderCallbackCreate: Listen for callbacks for the OAuth 2.0 provider.
// This specific endpoint listens for posts of form data.
//
// Parameters
//
//   - `provider`: An account provider.
//   - `body`: The authentication callback from the OAuth 2.0 client. This is typically posted to the redirect URL as query params after authenticating.
func (s *Oauth2Service) ProviderCallbackCreate(provider AccountProvider, body AuthCallback) error {
	// Create the url.
	path := "/oauth2/provider/{{.provider}}/callback"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as a form.
	form := url.Values{}
	encoder := schema.NewEncoder()
	err := encoder.Encode(body, form)
	if err != nil {
		return fmt.Errorf("encoding form body request failed: %v", err)
	}
	b := strings.NewReader(form.Encode())

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider": string(provider),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ProviderConsent: Get the consent URL and other information for the OAuth 2.0 provider.
// Parameters
//
//   - `provider`: An account provider.
//   - `callbackUrl`
func (s *Oauth2Service) ProviderConsent(provider AccountProvider, callbackUrl string) (*Oauth2ClientInfo, error) {
	// Create the url.
	path := "/oauth2/provider/{{.provider}}/consent"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider":     string(provider),
		"callback_url": callbackUrl,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Oauth2ClientInfo
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// TokenRevoke: Revoke an OAuth2 token.
// This endpoint is designed to be accessed from an *unauthenticated* API client.
//
// Parameters
//
//   - `body`: The request parameters for the OAuth 2.0 token revocation flow.
func (s *Oauth2Service) TokenRevoke(body TokenRevokeRequestForm) error {
	// Create the url.
	path := "/oauth2/token/revoke"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as a form.
	form := url.Values{}
	encoder := schema.NewEncoder()
	err := encoder.Encode(body, form)
	if err != nil {
		return fmt.Errorf("encoding form body request failed: %v", err)
	}
	b := strings.NewReader(form.Encode())

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// Get: Get an org.
// This endpoint requires authentication by an org admin. It gets the authenticated user's org.
func (s *OrgService) Get() (*Org, error) {
	// Create the url.
	path := "/org"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Org
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Create: Create an org.
// This endpoint requires authentication by a Zoo user that is not already in an org. It creates a new org for the authenticated user and makes them an admin.
//
// Parameters
//
//   - `body`: The user-modifiable parts of an organization.
func (s *OrgService) Create(body OrgDetails) (*Org, error) {
	// Create the url.
	path := "/org"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Org
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Update: Update an org.
// This endpoint requires authentication by an org admin. It updates the authenticated user's org.
//
// Parameters
//
//   - `body`: The user-modifiable parts of an organization.
func (s *OrgService) Update(body OrgDetails) (*Org, error) {
	// Create the url.
	path := "/org"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Org
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Delete: Delete an org.
// In order to delete an org, you must first delete all of its members, except yourself.
//
// You must also have no outstanding invoices or unpaid balances.
//
// This endpoint requires authentication by an org admin. It deletes the authenticated user's org.
func (s *OrgService) Delete() error {
	// Create the url.
	path := "/org"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// OrgList: List API calls for your org.
// This includes all API calls that were made by users in the org.
//
// This endpoint requires authentication by an org admin. It returns the API calls for the authenticated user's org.
//
// The API calls are returned in order of creation, with the most recently created API calls first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *APICallService) OrgList(limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/org/api-calls"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetForOrg: Get an API call for an org.
// This endpoint requires authentication by an org admin. It returns details of the requested API call for the user's org.
//
// Parameters
//
//   - `id`
func (s *APICallService) GetForOrg(id UUID) (*APICallWithPrice, error) {
	// Create the url.
	path := "/org/api-calls/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPrice
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DatasetS3Policies: Return the IAM policies customers should apply when onboarding an S3 dataset.
// Parameters
//
//   - `roleArn`
//   - `uri`
func (s *OrgService) DatasetS3Policies(roleArn string, uri string) (*DatasetS3Policies, error) {
	// Create the url.
	path := "/org/dataset/s3/policies"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"role_arn": roleArn,
		"uri":      uri,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded DatasetS3Policies
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListDatasets: List every dataset that belongs to the caller's organization.
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *OrgService) ListDatasets(limit int, pageToken string, sortBy CreatedAtSortMode) (*OrgDatasetResultsPage, error) {
	// Create the url.
	path := "/org/datasets"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgDatasetResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateDataset: Register a new org dataset.
// If the dataset lives in S3, call `/org/dataset/s3/policies` first so you can generate the trust, permission, and bucket policies scoped to your dataset before invoking this endpoint.
//
// Parameters
//
//   - `body`: Payload for creating an org dataset.
func (s *OrgService) CreateDataset(body CreateOrgDataset) (*OrgDataset, error) {
	// Create the url.
	path := "/org/datasets"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgDataset
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetDataset: Fetch a single dataset by id so long as it belongs to the authenticated org.
// Parameters
//
//   - `id`: A UUID usually v4 or v7
func (s *OrgService) GetDataset(id UUID) (*OrgDataset, error) {
	// Create the url.
	path := "/org/datasets/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgDataset
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateDataset: Update dataset metadata or storage credentials for the caller's organization.
// IMPORTANT: Use this endpoint to fix connectivity to the same underlying storage location (e.g. rotating credentials or correcting a typo). Do not repoint an existing dataset at a completely different bucket or providerâ€”create a new dataset instead so conversions in flight keep their original source. This warning applies to every storage backend, not just S3.
//
// Parameters
//
//   - `id`: A UUID usually v4 or v7
//   - `body`: Payload for updating an org dataset.
func (s *OrgService) UpdateDataset(id UUID, body UpdateOrgDataset) (*OrgDataset, error) {
	// Create the url.
	path := "/org/datasets/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgDataset
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteDataset: Delete a dataset owned by the caller's organization.
// This is a destructive operation that: - requires org admin authentication and the dataset must belong to the caller's org. - fails with a 409 Conflict if the dataset is still attached to any custom model. - deletes Zoo-managed artifacts for this dataset (converted outputs and embeddings). - does **not** delete or modify the customer's source bucket/prefix.
//
// All internal artifact deletions are strict; if any cleanup fails, the request fails.
//
// Parameters
//
//   - `id`: A UUID usually v4 or v7
func (s *OrgService) DeleteDataset(id UUID) error {
	// Create the url.
	path := "/org/datasets/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ListDatasetConversions: List the file conversions that have been processed for a given dataset owned by the caller's org.
// This endpoint returns lightweight conversion summaries only (including `phase`), and intentionally omits converted KCL output and snapshot image payloads for speed. Use the optional `filter` query parameter to filter results (example: `?filter=status:success`).
//
// Parameters
//
//   - `id`: A UUID usually v4 or v7
//   - `filter`
//   - `limit`
//   - `pageToken`
//   - `sortBy`: Supported sort modes for org dataset conversions.
func (s *OrgService) ListDatasetConversions(id UUID, filter string, limit int, pageToken string, sortBy ConversionSortMode) (*OrgDatasetFileConversionSummaryResultsPage, error) {
	// Create the url.
	path := "/org/datasets/{{.id}}/conversions"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":         id.String(),
		"filter":     filter,
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgDatasetFileConversionSummaryResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetDatasetConversion: Fetch the metadata and converted output for a single dataset conversion.
// Unlike list/search endpoints, this returns the full conversion payload: latest output text plus decoded snapshot image payloads for original, raw-KCL, and salon-KCL stages.
//
// Parameters
//
//   - `conversionId`: A UUID usually v4 or v7
//   - `id`: A UUID usually v4 or v7
func (s *OrgService) GetDatasetConversion(conversionId UUID, id UUID) (*OrgDatasetFileConversionDetails, error) {
	// Create the url.
	path := "/org/datasets/{{.id}}/conversions/{{.conversion_id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"conversion_id": conversionId.String(),
		"id":            id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgDatasetFileConversionDetails
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// RetriggerDatasetConversion: Retrigger a specific dataset conversion for the caller's org.
// Parameters
//
//   - `conversionId`: A UUID usually v4 or v7
//   - `id`: A UUID usually v4 or v7
func (s *OrgService) RetriggerDatasetConversion(conversionId UUID, id UUID) error {
	// Create the url.
	path := "/org/datasets/{{.id}}/conversions/{{.conversion_id}}/retrigger"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"conversion_id": conversionId.String(),
		"id":            id.String(),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// RetriggerDataset: Request a retrigger of conversions for a dataset that belongs to the caller's org.
// Parameters
//
//   - `id`: A UUID usually v4 or v7
//   - `statuses`
func (s *OrgService) RetriggerDataset(id UUID, statuses string) error {
	// Create the url.
	path := "/org/datasets/{{.id}}/retrigger"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":       id.String(),
		"statuses": statuses,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// SearchDatasetConversions: Search dataset conversions by conversion ID or file path.
// Supports exact conversion-ID matching and fuzzy file-path matching.
//
// Parameters
//
//   - `id`: A UUID usually v4 or v7
//   - `limit`
//   - `pageToken`
//   - `q`
//   - `sortBy`: Supported sort modes for org dataset conversions.
func (s *OrgService) SearchDatasetConversions(id UUID, limit int, pageToken string, q string, sortBy ConversionSortMode) (*OrgDatasetFileConversionSummaryResultsPage, error) {
	// Create the url.
	path := "/org/datasets/{{.id}}/search/conversions"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":         id.String(),
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"q":          q,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgDatasetFileConversionSummaryResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetDatasetConversionStats: Return aggregate conversion stats for a dataset owned by the caller's org.
// Parameters
//
//   - `id`: A UUID usually v4 or v7
func (s *OrgService) GetDatasetConversionStats(id UUID) (*OrgDatasetConversionStatsResponse, error) {
	// Create the url.
	path := "/org/datasets/{{.id}}/stats"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgDatasetConversionStatsResponse
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UploadDatasetFiles: Upload source files into a Zoo-managed dataset.
// This endpoint accepts `multipart/form-data` where each file part becomes a source object in the dataset. Paths are normalized and must be relative.
//
// Parameters
//
//   - `id`: A UUID usually v4 or v7
//   - `body`
func (s *OrgService) UploadDatasetFiles(id UUID, body *bytes.Buffer) (*UploadOrgDatasetFilesResponse, error) {
	// Create the url.
	path := "/org/datasets/{{.id}}/uploads"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, body)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "multipart/form-data")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UploadOrgDatasetFilesResponse
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListMembers: List members of your org.
// This endpoint requires authentication by an org admin. It lists the members of the authenticated user's org.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
//
//   - `role`: The roles for users in an organization.
func (s *OrgService) ListMembers(limit int, pageToken string, sortBy CreatedAtSortMode, role UserOrgRole) (*OrgMemberResultsPage, error) {
	// Create the url.
	path := "/org/members"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
		"role":       string(role),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgMemberResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateMember: Add a member to your org.
// If the user exists, this will add them to your org. If they do not exist, this will create a new user and add them to your org.
//
// In both cases the user gets an email that they have been added to the org.
//
// If the user is already in your org, this will return a 400 and a message.
//
// If the user is already in a different org, this will return a 400 and a message.
//
// This endpoint requires authentication by an org admin. It adds the specified member to the authenticated user's org.
//
// Parameters
//
//   - `body`: Data for adding a member to an org.
func (s *OrgService) CreateMember(body AddOrgMember) (*OrgMember, error) {
	// Create the url.
	path := "/org/members"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgMember
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetMember: Get a member of your org.
// This endpoint requires authentication by an org admin. It gets the specified member of the authenticated user's org.
//
// Parameters
//
//   - `userId`: A UUID usually v4 or v7
func (s *OrgService) GetMember(userId UUID) (*OrgMember, error) {
	// Create the url.
	path := "/org/members/{{.user_id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"user_id": userId.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgMember
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateMember: Update a member of your org.
// This endpoint requires authentication by an org admin. It updates the specified member of the authenticated user's org.
//
// Parameters
//
//   - `userId`: A UUID usually v4 or v7
//   - `body`: Data for updating a member of an org.
func (s *OrgService) UpdateMember(userId UUID, body UpdateMemberToOrgBody) (*OrgMember, error) {
	// Create the url.
	path := "/org/members/{{.user_id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"user_id": userId.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgMember
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteMember: Remove a member from your org.
// This endpoint requires authentication by an org admin. It removes the specified member from the authenticated user's org.
//
// Parameters
//
//   - `userId`: A UUID usually v4 or v7
func (s *OrgService) DeleteMember(userId UUID) error {
	// Create the url.
	path := "/org/members/{{.user_id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"user_id": userId.String(),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetInformationForOrg: Get payment info about your org.
// This includes billing address, phone, and name.
//
// This endpoint requires authentication by an org admin. It gets the payment information for the authenticated user's org.
func (s *PaymentService) GetInformationForOrg() (*Customer, error) {
	// Create the url.
	path := "/org/payment"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Customer
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateInformationForOrg: Create payment info for your org.
// This includes billing address, phone, and name.
//
// This endpoint requires authentication by the org admin. It creates the payment information for the authenticated user's org.
//
// Parameters
//
//   - `body`: The billing information for payments.
func (s *PaymentService) CreateInformationForOrg(body BillingInfo) (*Customer, error) {
	// Create the url.
	path := "/org/payment"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Customer
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateInformationForOrg: Update payment info for your org.
// This includes billing address, phone, and name.
//
// This endpoint requires authentication by an org admin. It updates the payment information for the authenticated user's org.
//
// Parameters
//
//   - `body`: The billing information for payments.
func (s *PaymentService) UpdateInformationForOrg(body BillingInfo) (*Customer, error) {
	// Create the url.
	path := "/org/payment"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Customer
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteInformationForOrg: Delete payment info for your org.
// This includes billing address, phone, and name.
//
// This endpoint requires authentication by an org admin. It deletes the payment information for the authenticated user's org.
func (s *PaymentService) DeleteInformationForOrg() error {
	// Create the url.
	path := "/org/payment"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetBalanceForOrg: Get balance for your org.
// This endpoint requires authentication by any member of an org. It gets the balance information for the authenticated user's org.
//
// Parameters
//
//   - `includeTotalDue`
func (s *PaymentService) GetBalanceForOrg(includeTotalDue bool) (*CustomerBalance, error) {
	// Create the url.
	path := "/org/payment/balance"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"include_total_due": strconv.FormatBool(includeTotalDue),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomerBalance
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateIntentForOrg: Create a payment intent for your org.
// This endpoint requires authentication by the org admin. It creates a new payment intent for the authenticated user's org's org.
func (s *PaymentService) CreateIntentForOrg() (*PaymentIntent, error) {
	// Create the url.
	path := "/org/payment/intent"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded PaymentIntent
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListInvoicesForOrg: List invoices for your org.
// This endpoint requires authentication by an org admin. It lists invoices for the authenticated user's org.
func (s *PaymentService) ListInvoicesForOrg() (*[]Invoice, error) {
	// Create the url.
	path := "/org/payment/invoices"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []Invoice
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListMethodsForOrg: List payment methods for your org.
// This endpoint requires authentication by an org admin. It lists payment methods for the authenticated user's org.
func (s *PaymentService) ListMethodsForOrg() (*[]PaymentMethod, error) {
	// Create the url.
	path := "/org/payment/methods"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []PaymentMethod
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteMethodForOrg: Delete a payment method for your org.
// This endpoint requires authentication by an org admin. It deletes the specified payment method for the authenticated user's org.
//
// Parameters
//
//   - `id`
func (s *PaymentService) DeleteMethodForOrg(id string) error {
	// Create the url.
	path := "/org/payment/methods/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetOrgSubscription: Get the subscription for an org.
// This endpoint requires authentication by any member of an org. It gets the subscription for the authenticated user's org.
func (s *PaymentService) GetOrgSubscription() (*ZooProductSubscriptions, error) {
	// Create the url.
	path := "/org/payment/subscriptions"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ZooProductSubscriptions
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateOrgSubscription: Create the subscription for an org.
// This endpoint requires authentication by an org admin. It creates the subscription for the authenticated user's org.
//
// Parameters
//
//   - `body`: A struct of Zoo product subscriptions an organization can request.
func (s *PaymentService) CreateOrgSubscription(body ZooProductSubscriptionsOrgRequest) (*ZooProductSubscriptions, error) {
	// Create the url.
	path := "/org/payment/subscriptions"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ZooProductSubscriptions
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateOrgSubscription: Update the subscription for an org.
// This endpoint requires authentication by an org admin. It updates the subscription for the authenticated user's org.
//
// Parameters
//
//   - `body`: A struct of Zoo product subscriptions an organization can request.
func (s *PaymentService) UpdateOrgSubscription(body ZooProductSubscriptionsOrgRequest) (*ZooProductSubscriptions, error) {
	// Create the url.
	path := "/org/payment/subscriptions"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ZooProductSubscriptions
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ValidateCustomerTaxInformationForOrg: Validate an orgs's information is correct and valid for automatic tax.
// This endpoint requires authentication by an org admin. It will return an error if the org's information is not valid for automatic tax. Otherwise, it will return an empty successful response.
func (s *PaymentService) ValidateCustomerTaxInformationForOrg() error {
	// Create the url.
	path := "/org/payment/tax"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetPrivacySettings: Get the privacy settings for an org.
// This endpoint requires authentication by an org admin. It gets the privacy settings for the authenticated user's org.
func (s *OrgService) GetPrivacySettings() (*PrivacySettings, error) {
	// Create the url.
	path := "/org/privacy"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded PrivacySettings
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdatePrivacySettings: Update the privacy settings for an org.
// This endpoint requires authentication by an org admin. It updates the privacy settings for the authenticated user's org.
//
// Parameters
//
//   - `body`: Privacy settings for an org or user.
func (s *OrgService) UpdatePrivacySettings(body PrivacySettings) (*PrivacySettings, error) {
	// Create the url.
	path := "/org/privacy"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded PrivacySettings
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetSamlIdp: Get the SAML identity provider.
// This endpoint requires authentication by an org admin.
func (s *OrgService) GetSamlIdp() (*SamlIdentityProvider, error) {
	// Create the url.
	path := "/org/saml/idp"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded SamlIdentityProvider
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateSamlIdp: Create a SAML identity provider.
// This endpoint requires authentication by an org admin.
//
// Parameters
//
//   - `body`: Parameters for creating a SAML identity provider.
func (s *OrgService) CreateSamlIdp(body SamlIdentityProviderCreate) (*SamlIdentityProvider, error) {
	// Create the url.
	path := "/org/saml/idp"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded SamlIdentityProvider
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateSamlIdp: Update the SAML identity provider.
// This endpoint requires authentication by an org admin.
//
// Parameters
//
//   - `body`: Parameters for creating a SAML identity provider.
func (s *OrgService) UpdateSamlIdp(body SamlIdentityProviderCreate) (*SamlIdentityProvider, error) {
	// Create the url.
	path := "/org/saml/idp"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded SamlIdentityProvider
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteSamlIdp: Delete an SAML identity provider.
// This endpoint requires authentication by an org admin.
func (s *OrgService) DeleteSamlIdp() error {
	// Create the url.
	path := "/org/saml/idp"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ListForOrg: List service accounts for your org.
// This endpoint requires authentication by an org member. It returns the service accounts for the organization.
//
// The service accounts are returned in order of creation, with the most recently created service accounts first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *ServiceAccountService) ListForOrg(limit int, pageToken string, sortBy CreatedAtSortMode) (*ServiceAccountResultsPage, error) {
	// Create the url.
	path := "/org/service-accounts"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ServiceAccountResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateForOrg: Create a new service account for your org.
// This endpoint requires authentication by an org member. It creates a new service account for the organization.
//
// Parameters
//
//   - `label`
func (s *ServiceAccountService) CreateForOrg(label string) (*ServiceAccount, error) {
	// Create the url.
	path := "/org/service-accounts"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"label": label,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ServiceAccount
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetForOrg: Get an service account for your org.
// This endpoint requires authentication by an org member. It returns details of the requested service account for the organization.
//
// Parameters
//
//   - `token`: An auth token. A uuid with a prefix of svc-
func (s *ServiceAccountService) GetForOrg(token string) (*ServiceAccount, error) {
	// Create the url.
	path := "/org/service-accounts/{{.token}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": token,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ServiceAccount
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteForOrg: Delete an service account for your org.
// This endpoint requires authentication by an org member. It deletes the requested service account for the organization.
//
// This endpoint does not actually delete the service account from the database. It merely marks the token as invalid. We still want to keep the service account in the database for historical purposes.
//
// Parameters
//
//   - `token`: An auth token. A uuid with a prefix of svc-
func (s *ServiceAccountService) DeleteForOrg(token string) error {
	// Create the url.
	path := "/org/service-accounts/{{.token}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": token,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetShortlinks: Get the shortlinks for an org.
// This endpoint requires authentication by an org admin. It gets the shortlinks for the authenticated user's org.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *OrgService) GetShortlinks(limit int, pageToken string, sortBy CreatedAtSortMode) (*ShortlinkResultsPage, error) {
	// Create the url.
	path := "/org/shortlinks"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ShortlinkResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// List: List orgs.
// This endpoint requires authentication by a Zoo employee. The orgs are returned in order of creation, with the most recently created orgs first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *OrgService) List(limit int, pageToken string, sortBy CreatedAtSortMode) (*OrgResultsPage, error) {
	// Create the url.
	path := "/orgs"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetAny: Get an org.
// This endpoint requires authentication by a Zoo employee. It gets the information for the specified org.
//
// Parameters
//
//   - `id`: A UUID usually v4 or v7
func (s *OrgService) GetAny(id UUID) (*Org, error) {
	// Create the url.
	path := "/orgs/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Org
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// AdminDetailsList: Get admin-only details for an organization.
// Zoo admins can retrieve extended information about any organization, while non-admins receive a 404 to avoid leaking existence.
//
// Parameters
//
//   - `id`: A UUID usually v4 or v7
func (s *OrgService) AdminDetailsList(id UUID) (*OrgAdminDetails, error) {
	// Create the url.
	path := "/orgs/{{.id}}/admin/details"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded OrgAdminDetails
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetBalanceForAnyOrg: Get balance for an org.
// This endpoint requires authentication by a Zoo employee. It gets the balance information for the specified org.
//
// Parameters
//
//   - `includeTotalDue`
//   - `id`: A UUID usually v4 or v7
func (s *PaymentService) GetBalanceForAnyOrg(includeTotalDue bool, id UUID) (*CustomerBalance, error) {
	// Create the url.
	path := "/orgs/{{.id}}/payment/balance"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"include_total_due": strconv.FormatBool(includeTotalDue),
		"id":                id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomerBalance
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateBalanceForAnyOrg: Update balance for an org.
// This endpoint requires authentication by a Zoo employee. It updates the balance information for the specified org.
//
// Parameters
//
//   - `id`: A UUID usually v4 or v7
//   - `includeTotalDue`
//   - `body`: Payload for updating a user's balance.
func (s *PaymentService) UpdateBalanceForAnyOrg(id UUID, includeTotalDue bool, body UpdatePaymentBalance) (*CustomerBalance, error) {
	// Create the url.
	path := "/orgs/{{.id}}/payment/balance"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":                id.String(),
		"include_total_due": strconv.FormatBool(includeTotalDue),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomerBalance
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateOrgSubscriptionForAnyOrg: Update the subscription for any org (admin override).
// This endpoint requires authentication by a Zoo admin. It updates the subscription for the specified org.
//
// Parameters
//
//   - `id`: A UUID usually v4 or v7
//   - `body`: A struct of Zoo product subscriptions an organization can request.
func (s *PaymentService) UpdateOrgSubscriptionForAnyOrg(id UUID, body ZooProductSubscriptionsOrgRequest) (*ZooProductSubscriptions, error) {
	// Create the url.
	path := "/orgs/{{.id}}/payment/subscriptions"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ZooProductSubscriptions
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Ping: Return pong.
func (s *MetaService) Ping() (*Pong, error) {
	// Create the url.
	path := "/ping"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Pong
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetPricingSubscriptions: Get the pricing for our subscriptions.
// This is the ultimate source of truth for the pricing of our subscriptions.
func (s *MetaService) GetPricingSubscriptions() (*map[string][]ZooProductSubscription, error) {
	// Create the url.
	path := "/pricing/subscriptions"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded map[string][]ZooProductSubscription
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateCoupon: Create a new store coupon.
// This endpoint requires authentication by a Zoo employee. It creates a new store coupon.
//
// Parameters
//
//   - `body`: The parameters for a new store coupon.
func (s *StoreService) CreateCoupon(body StoreCouponParams) (*DiscountCode, error) {
	// Create the url.
	path := "/store/coupon"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded DiscountCode
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpsertSubscriptionPlanPrice: Create or update a price for a subscription plan.
// You must be a Zoo admin to perform this request.
//
// Parameters
//
//   - `slug`
//   - `body`: Create or update a price row for a subscription plan.
func (s *PaymentService) UpsertSubscriptionPlanPrice(slug string, body PriceUpsertRequest) (*SubscriptionPlanPriceRecord, error) {
	// Create the url.
	path := "/subscription-plans/{{.slug}}/prices"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"slug": slug,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded SubscriptionPlanPriceRecord
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetAngleConversion: Convert angle units.
// Convert an angle unit value to another angle unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of angle formats.
//   - `outputUnit`: The valid types of angle formats.
//   - `value`
func (s *UnitService) GetAngleConversion(inputUnit UnitAngle, outputUnit UnitAngle, value float64) (*UnitAngleConversion, error) {
	// Create the url.
	path := "/unit/conversion/angle/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitAngleConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetAreaConversion: Convert area units.
// Convert an area unit value to another area unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of area units.
//   - `outputUnit`: The valid types of area units.
//   - `value`
func (s *UnitService) GetAreaConversion(inputUnit UnitArea, outputUnit UnitArea, value float64) (*UnitAreaConversion, error) {
	// Create the url.
	path := "/unit/conversion/area/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitAreaConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetCurrentConversion: Convert current units.
// Convert a current unit value to another current unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of current units.
//   - `outputUnit`: The valid types of current units.
//   - `value`
func (s *UnitService) GetCurrentConversion(inputUnit UnitCurrent, outputUnit UnitCurrent, value float64) (*UnitCurrentConversion, error) {
	// Create the url.
	path := "/unit/conversion/current/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitCurrentConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetEnergyConversion: Convert energy units.
// Convert a energy unit value to another energy unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of energy units.
//   - `outputUnit`: The valid types of energy units.
//   - `value`
func (s *UnitService) GetEnergyConversion(inputUnit UnitEnergy, outputUnit UnitEnergy, value float64) (*UnitEnergyConversion, error) {
	// Create the url.
	path := "/unit/conversion/energy/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitEnergyConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetForceConversion: Convert force units.
// Convert a force unit value to another force unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of force units.
//   - `outputUnit`: The valid types of force units.
//   - `value`
func (s *UnitService) GetForceConversion(inputUnit UnitForce, outputUnit UnitForce, value float64) (*UnitForceConversion, error) {
	// Create the url.
	path := "/unit/conversion/force/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitForceConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetFrequencyConversion: Convert frequency units.
// Convert a frequency unit value to another frequency unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of frequency units.
//   - `outputUnit`: The valid types of frequency units.
//   - `value`
func (s *UnitService) GetFrequencyConversion(inputUnit UnitFrequency, outputUnit UnitFrequency, value float64) (*UnitFrequencyConversion, error) {
	// Create the url.
	path := "/unit/conversion/frequency/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitFrequencyConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetLengthConversion: Convert length units.
// Convert a length unit value to another length unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of length units.
//   - `outputUnit`: The valid types of length units.
//   - `value`
func (s *UnitService) GetLengthConversion(inputUnit UnitLength, outputUnit UnitLength, value float64) (*UnitLengthConversion, error) {
	// Create the url.
	path := "/unit/conversion/length/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitLengthConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetMassConversion: Convert mass units.
// Convert a mass unit value to another mass unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of mass units.
//   - `outputUnit`: The valid types of mass units.
//   - `value`
func (s *UnitService) GetMassConversion(inputUnit UnitMas, outputUnit UnitMas, value float64) (*UnitMassConversion, error) {
	// Create the url.
	path := "/unit/conversion/mass/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitMassConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetPowerConversion: Convert power units.
// Convert a power unit value to another power unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of power units.
//   - `outputUnit`: The valid types of power units.
//   - `value`
func (s *UnitService) GetPowerConversion(inputUnit UnitPower, outputUnit UnitPower, value float64) (*UnitPowerConversion, error) {
	// Create the url.
	path := "/unit/conversion/power/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitPowerConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetPressureConversion: Convert pressure units.
// Convert a pressure unit value to another pressure unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of pressure units.
//   - `outputUnit`: The valid types of pressure units.
//   - `value`
func (s *UnitService) GetPressureConversion(inputUnit UnitPressure, outputUnit UnitPressure, value float64) (*UnitPressureConversion, error) {
	// Create the url.
	path := "/unit/conversion/pressure/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitPressureConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetTemperatureConversion: Convert temperature units.
// Convert a temperature unit value to another temperature unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of temperature units.
//   - `outputUnit`: The valid types of temperature units.
//   - `value`
func (s *UnitService) GetTemperatureConversion(inputUnit UnitTemperature, outputUnit UnitTemperature, value float64) (*UnitTemperatureConversion, error) {
	// Create the url.
	path := "/unit/conversion/temperature/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitTemperatureConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetTorqueConversion: Convert torque units.
// Convert a torque unit value to another torque unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of torque units.
//   - `outputUnit`: The valid types of torque units.
//   - `value`
func (s *UnitService) GetTorqueConversion(inputUnit UnitTorque, outputUnit UnitTorque, value float64) (*UnitTorqueConversion, error) {
	// Create the url.
	path := "/unit/conversion/torque/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitTorqueConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetVolumeConversion: Convert volume units.
// Convert a volume unit value to another volume unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of volume units.
//   - `outputUnit`: The valid types of volume units.
//   - `value`
func (s *UnitService) GetVolumeConversion(inputUnit UnitVolume, outputUnit UnitVolume, value float64) (*UnitVolumeConversion, error) {
	// Create the url.
	path := "/unit/conversion/volume/{{.input_unit}}/{{.output_unit}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitVolumeConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetSelf: Get your user.
// Get the user information for the authenticated user.
//
// Alternatively, you can also use the `/users/me` endpoint.
func (s *UserService) GetSelf() (*User, error) {
	// Create the url.
	path := "/user"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded User
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateSelf: Update your user.
// This endpoint requires authentication by any Zoo user. It updates information about the authenticated user.
//
// Parameters
//
//   - `body`: The user-modifiable parts of a User.
func (s *UserService) UpdateSelf(body UpdateUser) (*User, error) {
	// Create the url.
	path := "/user"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded User
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteSelf: Delete your user.
// This endpoint requires authentication by any Zoo user. It deletes the authenticated user from Zoo's database.
//
// This call will only succeed if all invoices associated with the user have been paid in full and there is no outstanding balance.
func (s *UserService) DeleteSelf() error {
	// Create the url.
	path := "/user"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// UserList: List API calls for your user.
// This endpoint requires authentication by any Zoo user. It returns the API calls for the authenticated user.
//
// The API calls are returned in order of creation, with the most recently created API calls first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *APICallService) UserList(limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/user/api-calls"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetForUser: Get an API call for a user.
// This endpoint requires authentication by any Zoo user. It returns details of the requested API call for the user.
//
// Parameters
//
//   - `id`
func (s *APICallService) GetForUser(id UUID) (*APICallWithPrice, error) {
	// Create the url.
	path := "/user/api-calls/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPrice
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListForUser: List API tokens for your user.
// This endpoint requires authentication by any Zoo user. It returns the API tokens for the authenticated user.
//
// The API tokens are returned in order of creation, with the most recently created API tokens first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *APITokenService) ListForUser(limit int, pageToken string, sortBy CreatedAtSortMode) (*APITokenResultsPage, error) {
	// Create the url.
	path := "/user/api-tokens"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APITokenResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateForUser: Create a new API token for your user.
// This endpoint requires authentication by any Zoo user. It creates a new API token for the authenticated user.
//
// Parameters
//
//   - `label`
func (s *APITokenService) CreateForUser(label string) (*APIToken, error) {
	// Create the url.
	path := "/user/api-tokens"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"label": label,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APIToken
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetForUser: Get an API token for your user.
// This endpoint requires authentication by any Zoo user. It returns details of the requested API token for the user.
//
// Parameters
//
//   - `token`: An auth token. A uuid with a prefix of api-
func (s *APITokenService) GetForUser(token string) (*APIToken, error) {
	// Create the url.
	path := "/user/api-tokens/{{.token}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": token,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APIToken
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteForUser: Delete an API token for your user.
// This endpoint requires authentication by any Zoo user. It deletes the requested API token for the user.
//
// This endpoint does not actually delete the API token from the database. It merely marks the token as invalid. We still want to keep the token in the database for historical purposes.
//
// Parameters
//
//   - `token`: An auth token. A uuid with a prefix of api-
func (s *APITokenService) DeleteForUser(token string) error {
	// Create the url.
	path := "/user/api-tokens/{{.token}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": token,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// PatchCrm: Update properties in the CRM
// Parameters
//
//   - `body`: The data for subscribing a user to the newsletter.
func (s *UserService) PatchCrm(body CrmData) error {
	// Create the url.
	path := "/user/crm"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PATCH", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetSelfExtended: Get extended information about your user.
// Get the user information for the authenticated user.
//
// Alternatively, you can also use the `/users-extended/me` endpoint.
func (s *UserService) GetSelfExtended() (*ExtendedUser, error) {
	// Create the url.
	path := "/user/extended"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ExtendedUser
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// FeaturesList: List user-visible feature flags enabled for the authenticated user.
// Returns only features that are marked as safe for exposure to clients and currently resolved to `true` for the requesting user (including org overrides).
func (s *UserService) FeaturesList() (*UserFeatureList, error) {
	// Create the url.
	path := "/user/features"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UserFeatureList
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// PutFormSelf: Create a new support/sales ticket from the website contact form. This endpoint is authenticated.
// It gets attached to the user's account.
//
// Parameters
//
//   - `body`: The form for a public inquiry submission.
func (s *UserService) PutFormSelf(body InquiryForm) error {
	// Create the url.
	path := "/user/form"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetOauth2ProvidersFor: Get the OAuth2 providers for your user.
// If this returns an empty array, then the user has not connected any OAuth2 providers and uses raw email authentication.
//
// This endpoint requires authentication by any Zoo user. It gets the providers for the authenticated user.
func (s *UserService) GetOauth2ProvidersFor() (*[]AccountProvider, error) {
	// Create the url.
	path := "/user/oauth2/providers"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []AccountProvider
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetUser: Get a user's org.
// This endpoint requires authentication by any Zoo user. It gets the authenticated user's org.
//
// If the user is not a member of an org, this endpoint will return a 404.
func (s *OrgService) GetUser() (*UserOrgInfo, error) {
	// Create the url.
	path := "/user/org"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UserOrgInfo
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetInformationForUser: Get payment info about your user.
// This includes billing address, phone, and name.
//
// This endpoint requires authentication by any Zoo user. It gets the payment information for the authenticated user.
func (s *PaymentService) GetInformationForUser() (*Customer, error) {
	// Create the url.
	path := "/user/payment"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Customer
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateInformationForUser: Create payment info for your user.
// This includes billing address, phone, and name.
//
// This endpoint requires authentication by any Zoo user. It creates the payment information for the authenticated user.
//
// Parameters
//
//   - `body`: The billing information for payments.
func (s *PaymentService) CreateInformationForUser(body BillingInfo) (*Customer, error) {
	// Create the url.
	path := "/user/payment"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Customer
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateInformationForUser: Update payment info for your user.
// This includes billing address, phone, and name.
//
// This endpoint requires authentication by any Zoo user. It updates the payment information for the authenticated user.
//
// Parameters
//
//   - `body`: The billing information for payments.
func (s *PaymentService) UpdateInformationForUser(body BillingInfo) (*Customer, error) {
	// Create the url.
	path := "/user/payment"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Customer
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteInformationForUser: Delete payment info for your user.
// This includes billing address, phone, and name.
//
// This endpoint requires authentication by any Zoo user. It deletes the payment information for the authenticated user.
func (s *PaymentService) DeleteInformationForUser() error {
	// Create the url.
	path := "/user/payment"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetBalanceForUser: Get balance for your user.
// This endpoint requires authentication by any Zoo user. It gets the balance information for the authenticated user.
//
// Parameters
//
//   - `includeTotalDue`
func (s *PaymentService) GetBalanceForUser(includeTotalDue bool) (*CustomerBalance, error) {
	// Create the url.
	path := "/user/payment/balance"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"include_total_due": strconv.FormatBool(includeTotalDue),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomerBalance
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateIntentForUser: Create a payment intent for your user.
// This endpoint requires authentication by any Zoo user. It creates a new payment intent for the authenticated user.
func (s *PaymentService) CreateIntentForUser() (*PaymentIntent, error) {
	// Create the url.
	path := "/user/payment/intent"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded PaymentIntent
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListInvoicesForUser: List invoices for your user.
// This endpoint requires authentication by any Zoo user. It lists invoices for the authenticated user.
func (s *PaymentService) ListInvoicesForUser() (*[]Invoice, error) {
	// Create the url.
	path := "/user/payment/invoices"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []Invoice
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListMethodsForUser: List payment methods for your user.
// This endpoint requires authentication by any Zoo user. It lists payment methods for the authenticated user.
func (s *PaymentService) ListMethodsForUser() (*[]PaymentMethod, error) {
	// Create the url.
	path := "/user/payment/methods"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []PaymentMethod
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteMethodForUser: Delete a payment method for your user.
// This endpoint requires authentication by any Zoo user. It deletes the specified payment method for the authenticated user.
//
// Parameters
//
//   - `id`
//   - `force`
func (s *PaymentService) DeleteMethodForUser(id string, force bool) error {
	// Create the url.
	path := "/user/payment/methods/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":    id,
		"force": strconv.FormatBool(force),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// SetDefaultMethodForUser: Set the default payment method for your user.
// This endpoint requires authentication by any Zoo user. It sets the default payment method for the authenticated user.
//
// Parameters
//
//   - `id`
func (s *PaymentService) SetDefaultMethodForUser(id string) error {
	// Create the url.
	path := "/user/payment/methods/{{.id}}/default"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetUserSubscription: Get the subscription for a user.
// This endpoint requires authentication by any Zoo user. It gets the subscription for the user.
func (s *PaymentService) GetUserSubscription() (*ZooProductSubscriptions, error) {
	// Create the url.
	path := "/user/payment/subscriptions"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ZooProductSubscriptions
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateUserSubscription: Create the subscription for a user.
// This endpoint requires authentication by any Zoo user. It creates the subscription for the user.
//
// Parameters
//
//   - `body`: A struct of Zoo product subscriptions a user can request.
func (s *PaymentService) CreateUserSubscription(body ZooProductSubscriptionsUserRequest) (*ZooProductSubscriptions, error) {
	// Create the url.
	path := "/user/payment/subscriptions"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ZooProductSubscriptions
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateUserSubscription: Update the user's subscription.
// This endpoint requires authentication by any Zoo user. It updates the subscription for the user.
//
// Parameters
//
//   - `body`: A struct of Zoo product subscriptions a user can request.
func (s *PaymentService) UpdateUserSubscription(body ZooProductSubscriptionsUserRequest) (*ZooProductSubscriptions, error) {
	// Create the url.
	path := "/user/payment/subscriptions"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ZooProductSubscriptions
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ValidateCustomerTaxInformationForUser: Validate a user's information is correct and valid for automatic tax.
// This endpoint requires authentication by any Zoo user. It will return an error if the user's information is not valid for automatic tax. Otherwise, it will return an empty successful response.
func (s *PaymentService) ValidateCustomerTaxInformationForUser() error {
	// Create the url.
	path := "/user/payment/tax"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetPrivacySettings: Get the privacy settings for a user.
// This endpoint requires authentication by any Zoo user. It gets the privacy settings for the user.
func (s *UserService) GetPrivacySettings() (*PrivacySettings, error) {
	// Create the url.
	path := "/user/privacy"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded PrivacySettings
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdatePrivacySettings: Update the user's privacy settings.
// This endpoint requires authentication by any Zoo user. It updates the privacy settings for the user.
//
// Parameters
//
//   - `body`: Privacy settings for an org or user.
func (s *UserService) UpdatePrivacySettings(body PrivacySettings) (*PrivacySettings, error) {
	// Create the url.
	path := "/user/privacy"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded PrivacySettings
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetSessionFor: Get a session for your user.
// This endpoint requires authentication by any Zoo user. It returns details of the requested API token for the user.
//
// Parameters
//
//   - `token`: An auth token. A uuid with a prefix of ses-
func (s *UserService) GetSessionFor(token string) (*Session, error) {
	// Create the url.
	path := "/user/session/{{.token}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": token,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Session
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetShortlinks: Get the shortlinks for a user.
// This endpoint requires authentication by any Zoo user. It gets the shortlinks for the user.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *UserService) GetShortlinks(limit int, pageToken string, sortBy CreatedAtSortMode) (*ShortlinkResultsPage, error) {
	// Create the url.
	path := "/user/shortlinks"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ShortlinkResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateShortlink: Create a shortlink for a user.
// This endpoint requires authentication by any Zoo user. It creates a shortlink for the user.
//
// Parameters
//
//   - `body`: Request to create a shortlink.
func (s *UserService) CreateShortlink(body CreateShortlinkRequest) (*CreateShortlinkResponse, error) {
	// Create the url.
	path := "/user/shortlinks"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CreateShortlinkResponse
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// RedirectUserShortlink: Redirect the user to the URL for the shortlink.
// This endpoint might require authentication by a Zoo user. It gets the shortlink for the user and redirects them to the URL. If the shortlink is owned by an org, the user must be a member of the org.
//
// Parameters
//
//   - `key`
func (s *HiddenService) RedirectUserShortlink(key string) error {
	// Create the url.
	path := "/user/shortlinks/{{.key}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"key": key,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// UpdateShortlink: Update a shortlink for a user.
// This endpoint requires authentication by any Zoo user. It updates a shortlink for the user.
//
// This endpoint really only allows you to change the `restrict_to_org` setting of a shortlink. Thus it is only useful for folks who are part of an org. If you are not part of an org, you will not be able to change the `restrict_to_org` status.
//
// Parameters
//
//   - `key`
//   - `body`: Request to update a shortlink.
func (s *UserService) UpdateShortlink(key string, body UpdateShortlinkRequest) error {
	// Create the url.
	path := "/user/shortlinks/{{.key}}"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"key": key,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// DeleteShortlink: Delete a shortlink for a user.
// This endpoint requires authentication by any Zoo user. It deletes a shortlink for the user.
//
// Parameters
//
//   - `key`
func (s *UserService) DeleteShortlink(key string) error {
	// Create the url.
	path := "/user/shortlinks/{{.key}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"key": key,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ListTextToCadPartsForUser: List text-to-CAD parts you've generated.
// This will always return the STEP file contents as well as the format the user originally requested.
//
// This endpoint requires authentication by any Zoo user. It returns the text-to-CAD parts for the authenticated user.
//
// The text-to-CAD parts are returned in order of creation, with the most recently created text-to-CAD parts first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
//
//   - `conversationId`: A UUID usually v4 or v7
//
//   - `noModels`
//
//   - `noParts`
func (s *MlService) ListTextToCadPartsForUser(limit int, pageToken string, sortBy CreatedAtSortMode, conversationId UUID, noModels bool, noParts bool) (*TextToCadResponseResultsPage, error) {
	// Create the url.
	path := "/user/text-to-cad"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":           strconv.Itoa(limit),
		"page_token":      pageToken,
		"sort_by":         string(sortBy),
		"conversation_id": conversationId.String(),
		"no_models":       strconv.FormatBool(noModels),
		"no_parts":        strconv.FormatBool(noParts),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded TextToCadResponseResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetTextToCadPartForUser: Get a text-to-CAD response.
// This endpoint requires authentication by any Zoo user. The user must be the owner of the text-to-CAD model.
//
// Parameters
//
//   - `id`
func (s *MlService) GetTextToCadPartForUser(id UUID) (*any, error) {
	// Create the url.
	path := "/user/text-to-cad/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded any
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateTextToCadPartFeedback: Give feedback to a specific ML response.
// This can be a text-to-CAD creation or iteration.
//
// This endpoint requires authentication by any Zoo user. The user must be the owner of the ML response, in order to give feedback.
//
// Parameters
//
//   - `id`
//   - `feedback`: Human feedback on an ML response.
func (s *MlService) CreateTextToCadPartFeedback(id UUID, feedback MlFeedback) error {
	// Create the url.
	path := "/user/text-to-cad/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", targetURL, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":       id.String(),
		"feedback": string(feedback),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// List: List users.
// This endpoint requires authentication by a Zoo employee. The users are returned in order of creation, with the most recently created users first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *UserService) List(limit int, pageToken string, sortBy CreatedAtSortMode) (*UserResultsPage, error) {
	// Create the url.
	path := "/users"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListExtended: List users with extended information.
// This endpoint requires authentication by a Zoo employee. The users are returned in order of creation, with the most recently created users first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *UserService) ListExtended(limit int, pageToken string, sortBy CreatedAtSortMode) (*ExtendedUserResultsPage, error) {
	// Create the url.
	path := "/users-extended"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ExtendedUserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetExtended: Get extended information about a user.
// To get information about yourself, use `/users-extended/me` as the endpoint. By doing so you will get the user information for the authenticated user.
//
// Alternatively, to get information about the authenticated user, use `/user/extended` endpoint.
//
// Parameters
//
//   - `id`
func (s *UserService) GetExtended(id string) (*ExtendedUser, error) {
	// Create the url.
	path := "/users-extended/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ExtendedUser
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Get: Get a user.
// To get information about yourself, use `/users/me` as the endpoint. By doing so you will get the user information for the authenticated user.
//
// Alternatively, to get information about the authenticated user, use `/user` endpoint.
//
// Parameters
//
//   - `id`
func (s *UserService) Get(id string) (*User, error) {
	// Create the url.
	path := "/users/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded User
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// AdminDetailsList: Get admin-only details for a user.
// Zoo admins can retrieve extended information about any user, while non-admins receive a 404 to avoid leaking the existence of the resource.
//
// Parameters
//
//   - `id`
func (s *UserService) AdminDetailsList(id string) (*UserAdminDetails, error) {
	// Create the url.
	path := "/users/{{.id}}/admin/details"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UserAdminDetails
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListForUser: List API calls for a user.
// This endpoint requires authentication by any Zoo user. It returns the API calls for the authenticated user if "me" is passed as the user id.
//
// Alternatively, you can use the `/user/api-calls` endpoint to get the API calls for your user.
//
// If the authenticated user is a Zoo employee, then the API calls are returned for the user specified by the user id.
//
// The API calls are returned in order of creation, with the most recently created API calls first.
//
// Parameters
//
//   - `id`
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *APICallService) ListForUser(id string, limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/users/{{.id}}/api-calls"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":         id,
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetBalanceForAnyUser: Get balance for an user.
// This endpoint requires authentication by a Zoo employee. It gets the balance information for the specified user.
//
// Parameters
//
//   - `id`
//   - `includeTotalDue`
func (s *PaymentService) GetBalanceForAnyUser(id string, includeTotalDue bool) (*CustomerBalance, error) {
	// Create the url.
	path := "/users/{{.id}}/payment/balance"
	targetURL := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":                id,
		"include_total_due": strconv.FormatBool(includeTotalDue),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomerBalance
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateBalanceForAnyUser: Update balance for an user.
// This endpoint requires authentication by a Zoo employee. It updates the balance information for the specified user.
//
// Parameters
//
//   - `id`
//   - `includeTotalDue`
//   - `body`: Payload for updating a user's balance.
func (s *PaymentService) UpdateBalanceForAnyUser(id string, includeTotalDue bool, body UpdatePaymentBalance) (*CustomerBalance, error) {
	// Create the url.
	path := "/users/{{.id}}/payment/balance"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":                id,
		"include_total_due": strconv.FormatBool(includeTotalDue),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomerBalance
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateSubscriptionFor: Update a subscription for a user.
// You must be a Zoo admin to perform this request.
//
// Parameters
//
//   - `id`
//   - `body`: A struct of Zoo product subscriptions a user can request.
func (s *UserService) UpdateSubscriptionFor(id string, body ZooProductSubscriptionsUserRequest) (*ZooProductSubscriptions, error) {
	// Create the url.
	path := "/users/{{.id}}/payment/subscriptions"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ZooProductSubscriptions
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// PutPublicForm: Creates a new support/sales ticket from the website contact form. This endpoint is for untrusted
// users and is not authenticated.
//
// Parameters
//
//   - `body`: The form for a public inquiry submission.
func (s *UserService) PutPublicForm(body InquiryForm) error {
	// Create the url.
	path := "/website/form"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// PutPublicSubscribe: Subscribes a user to the newsletter.
// Parameters
//
//   - `body`: The data for subscribing a user to the newsletter.
func (s *UserService) PutPublicSubscribe(body Subscribe) error {
	// Create the url.
	path := "/website/subscribe"
	targetURL := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", targetURL, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// CreateTerm: Create a terminal.
// Attach to a docker container to create an interactive terminal.
func (s *ExecutorService) CreateTerm() (*websocket.Conn, error) {
	// Create the url.
	path := "/ws/executor/term"
	targetURL := resolveRelative(s.client.server, path)

	headers := http.Header{}
	headers["Authorization"] = []string{fmt.Sprintf("Bearer %s", s.client.token)}

	conn, _, err := websocket.DefaultDialer.Dial(strings.ReplaceAll(targetURL, "https://", "wss://"), headers)
	if err != nil {
		return nil, err
	}

	return conn, nil
}

// CopilotWs: Open a websocket to prompt the ML copilot.
// This endpoint accepts typed query parameters via `MlCopilotQuery`. See the field documentation on that struct for details, including replay behavior and wire format.
//
// Parameters
//
//   - `conversationId`
//   - `replay`
//   - `pr`
//   - `body`: The types of messages that can be sent by the client to the server.
func (s *MlService) CopilotWs(conversationId UUID, replay bool, pr int, body any) (*websocket.Conn, error) {
	// Create the url.
	path := "/ws/ml/copilot"
	targetURL := resolveRelative(s.client.server, path)

	headers := http.Header{}
	headers["Authorization"] = []string{fmt.Sprintf("Bearer %s", s.client.token)}

	conn, _, err := websocket.DefaultDialer.Dial(strings.ReplaceAll(targetURL, "https://", "wss://"), headers)
	if err != nil {
		return nil, err
	}

	return conn, nil
}

// ReasoningWs: Open a websocket to prompt the ML copilot.
// Parameters
//
//   - `id`
//   - `body`: The types of messages that can be sent by the client to the server.
func (s *MlService) ReasoningWs(id UUID, body any) (*websocket.Conn, error) {
	// Create the url.
	path := "/ws/ml/reasoning/{{.id}}"
	targetURL := resolveRelative(s.client.server, path)

	headers := http.Header{}
	headers["Authorization"] = []string{fmt.Sprintf("Bearer %s", s.client.token)}

	conn, _, err := websocket.DefaultDialer.Dial(strings.ReplaceAll(targetURL, "https://", "wss://"), headers)
	if err != nil {
		return nil, err
	}

	return conn, nil
}

// CommandsWs: Open a websocket which accepts modeling commands.
// Pass those commands to the engine via websocket, and pass responses back to the client. Basically, this is a websocket proxy between the frontend/client and the engine.
//
// Parameters
//
//   - `apicallId`
//   - `fps`
//   - `orderIndependentTransparency`
//   - `pool`
//   - `postEffect`: Post effect type
//   - `replay`
//   - `showGrid`
//   - `unlockedFramerate`
//   - `videoResHeight`
//   - `videoResWidth`
//   - `webrtc`
//   - `pr`
//   - `body`: The websocket messages the server receives.
func (s *ModelingService) CommandsWs(apicallId string, fps int, orderIndependentTransparency bool, pool string, postEffect PostEffectType, replay string, showGrid bool, unlockedFramerate bool, videoResHeight int, videoResWidth int, webrtc bool, pr int, body any) (*websocket.Conn, error) {
	// Create the url.
	path := "/ws/modeling/commands"
	targetURL := resolveRelative(s.client.server, path)

	headers := http.Header{}
	headers["Authorization"] = []string{fmt.Sprintf("Bearer %s", s.client.token)}

	conn, _, err := websocket.DefaultDialer.Dial(strings.ReplaceAll(targetURL, "https://", "wss://"), headers)
	if err != nil {
		return nil, err
	}

	return conn, nil
}
