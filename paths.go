// Code generated by `generate`. DO NOT EDIT.

package kittycad

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/gorilla/schema"
	"github.com/gorilla/websocket"
)

// GetSchema: Get OpenAPI schema.
func (s *MetaService) GetSchema() error {
	// Create the url.
	path := "/"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetAiPluginManifest: Get AI plugin manifest.
func (s *MetaService) GetAiPluginManifest() (*AiPluginManifest, error) {
	// Create the url.
	path := "/.well-known/ai-plugin.json"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded AiPluginManifest
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Getdata: Get the metadata about our currently running server.
// This includes information on any of our other distributed systems it is connected to.
// You must be a KittyCAD employee to perform this request.
func (s *MetaService) Getdata() (*Metadata, error) {
	// Create the url.
	path := "/_meta/info"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Metadata
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateImageTo3D: Generate a 3D model from an image.
// This is an alpha endpoint. It will change in the future. The current output is honestly pretty bad. So if you find this endpoint, you get what you pay for, which currently is nothing. But in the future will be made a lot better.
//
// Parameters
//
//   - `inputFormat`: An enumeration.
//   - `outputFormat`: The valid types of output file formats.
//   - `body`
func (s *AiService) CreateImageTo3D(inputFormat ImageType, outputFormat FileExportFormat, body []byte) (*Mesh, error) {
	// Create the url.
	path := "/ai/image-to-3d/{{.input_format}}/{{.output_format}}"
	uri := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_format":  string(inputFormat),
		"output_format": string(outputFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Mesh
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateTextTo3D: Generate a 3D model from text.
// This is an alpha endpoint. It will change in the future. The current output is honestly pretty bad. So if you find this endpoint, you get what you pay for, which currently is nothing. But in the future will be made a lot better.
//
// Parameters
//
//   - `outputFormat`: The valid types of output file formats.
//   - `prompt`
func (s *AiService) CreateTextTo3D(outputFormat FileExportFormat, prompt string) (*Mesh, error) {
	// Create the url.
	path := "/ai/text-to-3d/{{.output_format}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_format": string(outputFormat),
		"prompt":        prompt,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Mesh
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetMetrics: Get API call metrics.
// This endpoint requires authentication by a KittyCAD employee. The API calls are grouped by the parameter passed.
//
// Parameters
//
//   - `groupBy`: The field of an API call to group by.
func (s *APICallService) GetMetrics(groupBy APICallQueryGroupBy) (*[]APICallQueryGroup, error) {
	// Create the url.
	path := "/api-call-metrics"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"group_by": string(groupBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []APICallQueryGroup
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// List: List API calls.
// This endpoint requires authentication by a KittyCAD employee. The API calls are returned in order of creation, with the most recently created API calls first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *APICallService) List(limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/api-calls"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Get: Get details of an API call.
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested API call for the user.
// If the user is not authenticated to view the specified API call, then it is not returned.
// Only KittyCAD employees can view API calls for other users.
//
// Parameters
//
//   - `id`
func (s *APICallService) Get(id string) (*APICallWithPrice, error) {
	// Create the url.
	path := "/api-calls/{{.id}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPrice
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GithubCallback: Listen for callbacks to GitHub app authentication.
// This is different than OAuth 2.0 authentication for users. This endpoint grants access for KittyCAD to access user's repos.
// The user doesn't need KittyCAD OAuth authorization for this endpoint, this is purely for the GitHub permissions to access repos.
//
// Parameters
//
//   - `body`
func (s *AppService) GithubCallback(body any) error {
	// Create the url.
	path := "/apps/github/callback"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("GET", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GithubConsent: Get the consent URL for GitHub app authentication.
// This is different than OAuth 2.0 authentication for users. This endpoint grants access for KittyCAD to access user's repos.
// The user doesn't need KittyCAD OAuth authorization for this endpoint, this is purely for the GitHub permissions to access repos.
func (s *AppService) GithubConsent() (*AppClientInfo, error) {
	// Create the url.
	path := "/apps/github/consent"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded AppClientInfo
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GithubWebhook: Listen for GitHub webhooks.
// These come from the GitHub app.
//
// Parameters
//
//   - `body`
func (s *AppService) GithubWebhook(body []byte) error {
	// Create the url.
	path := "/apps/github/webhook"
	uri := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ListAsyncOperations: List async operations.
// For async file conversion operations, this endpoint does not return the contents of converted files (`output`). To get the contents use the `/async/operations/{id}` endpoint.
// This endpoint requires authentication by a KittyCAD employee.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
//
//   - `status`: The status of an async API call.
func (s *APICallService) ListAsyncOperations(limit int, pageToken string, sortBy CreatedAtSortMode, status APICallStatus) (*AsyncAPICallResultsPage, error) {
	// Create the url.
	path := "/async/operations"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
		"status":     string(status),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded AsyncAPICallResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetAsyncOperation: Get an async operation.
// Get the status and output of an async operation.
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested async operation for the user.
// If the user is not authenticated to view the specified async operation, then it is not returned.
// Only KittyCAD employees with the proper access can view async operations for other users.
//
// Parameters
//
//   - `id`
func (s *APICallService) GetAsyncOperation(id string) (*any, error) {
	// Create the url.
	path := "/async/operations/{{.id}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded any
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// AuthEmail: Create an email verification request for a user.
// Parameters
//
//   - `body`: The body of the form for email authentication.
func (s *HiddenService) AuthEmail(body EmailAuthenticationForm) (*VerificationToken, error) {
	// Create the url.
	path := "/auth/email"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded VerificationToken
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// AuthEmailCallback: Listen for callbacks for email verification for users.
// Parameters
//
//   - `callbackUrl`
//   - `email`
//   - `token`
func (s *HiddenService) AuthEmailCallback(callbackUrl URL, email string, token string) error {
	// Create the url.
	path := "/auth/email/callback"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"callback_url": callbackUrl.String(),
		"email":        email,
		"token":        token,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// CreateCenterOfMass: Get CAD file center of mass.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
// This endpoint returns the cartesian co-ordinate in world space measure units.
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
// Get the center of mass of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `outputUnit`: The valid types of length units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateCenterOfMass(outputUnit UnitLength, srcFormat FileImportFormat, body []byte) (*FileCenterOfMass, error) {
	// Create the url.
	path := "/file/center-of-mass"
	uri := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_unit": string(outputUnit),
		"src_format":  string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileCenterOfMass
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateConversion: Convert CAD file with defaults.
// If you wish to specify the conversion options, use the `/file/conversion` endpoint instead.
// Convert a CAD file from one format to another. If the file being converted is larger than 25MB, it will be performed asynchronously.
// If the conversion is performed synchronously, the contents of the converted file (`output`) will be returned as a base64 encoded string.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `outputFormat`: The valid types of output file formats.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateConversion(outputFormat FileExportFormat, srcFormat FileImportFormat, body []byte) (*FileConversion, error) {
	// Create the url.
	path := "/file/conversion/{{.src_format}}/{{.output_format}}"
	uri := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_format": string(outputFormat),
		"src_format":    string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateDensity: Get CAD file density.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
// This endpoint assumes if you are giving a material mass in a specific mass units, we return a density in mass unit per cubic measure unit.
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
// Get the density of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `materialMass`
//   - `materialMassUnit`: The valid types of mass units.
//   - `outputUnit`: The valid types for density units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateDensity(materialMass float64, materialMassUnit UnitMas, outputUnit UnitDensity, srcFormat FileImportFormat, body []byte) (*FileDensity, error) {
	// Create the url.
	path := "/file/density"
	uri := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"material_mass":      fmt.Sprintf("%f", materialMass),
		"material_mass_unit": string(materialMassUnit),
		"output_unit":        string(outputUnit),
		"src_format":         string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileDensity
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateFileExecution: Execute a KittyCAD program in a specific language.
// Parameters
//
//   - `lang`: The language code is written in.
//   - `output`
//   - `body`
func (s *ExecutorService) CreateFileExecution(lang CodeLanguage, output string, body []byte) (*CodeOutput, error) {
	// Create the url.
	path := "/file/execute/{{.lang}}"
	uri := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"lang":   string(lang),
		"output": output,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CodeOutput
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateMass: Get CAD file mass.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
// This endpoint assumes if you are giving a material density in a specific mass unit per cubic measure unit, we return a mass in mass units. The same mass units as passed in the material density.
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
// Get the mass of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `materialDensity`
//   - `materialDensityUnit`: The valid types for density units.
//   - `outputUnit`: The valid types of mass units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateMass(materialDensity float64, materialDensityUnit UnitDensity, outputUnit UnitMas, srcFormat FileImportFormat, body []byte) (*FileMass, error) {
	// Create the url.
	path := "/file/mass"
	uri := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"material_density":      fmt.Sprintf("%f", materialDensity),
		"material_density_unit": string(materialDensityUnit),
		"output_unit":           string(outputUnit),
		"src_format":            string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileMass
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateSurfaceArea: Get CAD file surface area.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
// This endpoint returns the square measure units.
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
// Get the surface area of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `outputUnit`: The valid types of area units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateSurfaceArea(outputUnit UnitArea, srcFormat FileImportFormat, body []byte) (*FileSurfaceArea, error) {
	// Create the url.
	path := "/file/surface-area"
	uri := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_unit": string(outputUnit),
		"src_format":  string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileSurfaceArea
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateVolume: Get CAD file volume.
// We assume any file given to us has one consistent unit throughout. We also assume the file is at the proper scale.
// This endpoint returns the cubic measure units.
// In the future, we will use the units inside the file if they are given and do any conversions if necessary for the calculation. But currently, that is not supported.
// Get the volume of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters
//
//   - `outputUnit`: The valid types of volume units.
//   - `srcFormat`: The valid types of source file formats.
//   - `body`
func (s *FileService) CreateVolume(outputUnit UnitVolume, srcFormat FileImportFormat, body []byte) (*FileVolume, error) {
	// Create the url.
	path := "/file/volume"
	uri := resolveRelative(s.client.server, path)

	b := bytes.NewReader(body)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/octet-stream")

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_unit": string(outputUnit),
		"src_format":  string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded FileVolume
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Logout: This endpoint removes the session cookie for a user.
// This is used in logout scenarios.
func (s *HiddenService) Logout() error {
	// Create the url.
	path := "/logout"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// Cmd: Submit one modeling operation.
// Response depends on which command was submitted, so unfortunately the OpenAPI schema can't generate the right response type.
//
// Parameters
//
//   - `body`: A graphics command submitted to the KittyCAD engine via the Modeling API.
func (s *ModelingService) Cmd(body ModelingCmdReq) (*any, error) {
	// Create the url.
	path := "/modeling/cmd"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded any
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CmdBatch: Submit many modeling operations.
// Parameters
//
//   - `body`: A batch set of graphics commands submitted to the KittyCAD engine via the Modeling API.
func (s *ModelingService) CmdBatch(body ModelingCmdReqBatch) (*ModelingOutcomes, error) {
	// Create the url.
	path := "/modeling/cmd-batch"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ModelingOutcomes
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeviceAuthRequest: Start an OAuth 2.0 Device Authorization Grant.
// This endpoint is designed to be accessed from an *unauthenticated* API client. It generates and records a `device_code` and `user_code` which must be verified and confirmed prior to a token being granted.
//
// Parameters
//
//   - `body`: The request parameters for the OAuth 2.0 Device Authorization Grant flow.
func (s *Oauth2Service) DeviceAuthRequest(body DeviceAuthRequestForm) error {
	// Create the url.
	path := "/oauth2/device/auth"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as a form.
	form := url.Values{}
	encoder := schema.NewEncoder()
	err := encoder.Encode(body, form)
	if err != nil {
		return fmt.Errorf("encoding form body request failed: %v", err)
	}
	b := strings.NewReader(form.Encode())

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// DeviceAuthConfirm: Confirm an OAuth 2.0 Device Authorization Grant.
// This endpoint is designed to be accessed by the user agent (browser), not the client requesting the token. So we do not actually return the token here; it will be returned in response to the poll on `/oauth2/device/token`.
//
// Parameters
//
//   - `body`: The request parameters to verify the `user_code` for the OAuth 2.0 Device Authorization Grant.
func (s *Oauth2Service) DeviceAuthConfirm(body DeviceAuthVerifyParams) error {
	// Create the url.
	path := "/oauth2/device/confirm"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// DeviceAccessToken: Request a device access token.
// This endpoint should be polled by the client until the user code is verified and the grant is confirmed.
//
// Parameters
//
//   - `body`: The form for a device access token request.
func (s *Oauth2Service) DeviceAccessToken(body DeviceAccessTokenRequestForm) error {
	// Create the url.
	path := "/oauth2/device/token"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as a form.
	form := url.Values{}
	encoder := schema.NewEncoder()
	err := encoder.Encode(body, form)
	if err != nil {
		return fmt.Errorf("encoding form body request failed: %v", err)
	}
	b := strings.NewReader(form.Encode())

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// DeviceAuthVerify: Verify an OAuth 2.0 Device Authorization Grant.
// This endpoint should be accessed in a full user agent (e.g., a browser). If the user is not logged in, we redirect them to the login page and use the `callback_url` parameter to get them to the UI verification form upon logging in. If they are logged in, we redirect them to the UI verification form on the website.
//
// Parameters
//
//   - `userCode`
func (s *Oauth2Service) DeviceAuthVerify(userCode string) error {
	// Create the url.
	path := "/oauth2/device/verify"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"user_code": userCode,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ProviderCallback: Listen for callbacks for the OAuth 2.0 provider.
// Parameters
//
//   - `provider`: An account provider.
//   - `code`
//   - `state`
func (s *Oauth2Service) ProviderCallback(provider AccountProvider, code string, state string) error {
	// Create the url.
	path := "/oauth2/provider/{{.provider}}/callback"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider": string(provider),
		"code":     code,
		"state":    state,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ProviderConsent: Get the consent URL and other information for the OAuth 2.0 provider.
// Parameters
//
//   - `provider`: An account provider.
//   - `callbackUrl`
func (s *Oauth2Service) ProviderConsent(provider AccountProvider, callbackUrl string) (*Oauth2ClientInfo, error) {
	// Create the url.
	path := "/oauth2/provider/{{.provider}}/consent"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider":     string(provider),
		"callback_url": callbackUrl,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Oauth2ClientInfo
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetOpenaiSchema: Get AI plugin OpenAPI schema.
// This is the same as the OpenAPI schema, BUT it has some modifications to make it compatible with OpenAI. For example, descriptions must be < 300 chars.
func (s *MetaService) GetOpenaiSchema() error {
	// Create the url.
	path := "/openai/openapi.json"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// Ping: Return pong.
func (s *MetaService) Ping() (*Pong, error) {
	// Create the url.
	path := "/ping"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Pong
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetAngleConversion: Convert angle units.
// Convert an angle unit value to another angle unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of angle formats.
//   - `outputUnit`: The valid types of angle formats.
//   - `value`
func (s *UnitService) GetAngleConversion(inputUnit UnitAngle, outputUnit UnitAngle, value float64) (*UnitAngleConversion, error) {
	// Create the url.
	path := "/unit/conversion/angle/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitAngleConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetAreaConversion: Convert area units.
// Convert an area unit value to another area unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of area units.
//   - `outputUnit`: The valid types of area units.
//   - `value`
func (s *UnitService) GetAreaConversion(inputUnit UnitArea, outputUnit UnitArea, value float64) (*UnitAreaConversion, error) {
	// Create the url.
	path := "/unit/conversion/area/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitAreaConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetCurrentConversion: Convert current units.
// Convert a current unit value to another current unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of current units.
//   - `outputUnit`: The valid types of current units.
//   - `value`
func (s *UnitService) GetCurrentConversion(inputUnit UnitCurrent, outputUnit UnitCurrent, value float64) (*UnitCurrentConversion, error) {
	// Create the url.
	path := "/unit/conversion/current/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitCurrentConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetEnergyConversion: Convert energy units.
// Convert a energy unit value to another energy unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of energy units.
//   - `outputUnit`: The valid types of energy units.
//   - `value`
func (s *UnitService) GetEnergyConversion(inputUnit UnitEnergy, outputUnit UnitEnergy, value float64) (*UnitEnergyConversion, error) {
	// Create the url.
	path := "/unit/conversion/energy/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitEnergyConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetForceConversion: Convert force units.
// Convert a force unit value to another force unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of force units.
//   - `outputUnit`: The valid types of force units.
//   - `value`
func (s *UnitService) GetForceConversion(inputUnit UnitForce, outputUnit UnitForce, value float64) (*UnitForceConversion, error) {
	// Create the url.
	path := "/unit/conversion/force/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitForceConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetFrequencyConversion: Convert frequency units.
// Convert a frequency unit value to another frequency unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of frequency units.
//   - `outputUnit`: The valid types of frequency units.
//   - `value`
func (s *UnitService) GetFrequencyConversion(inputUnit UnitFrequency, outputUnit UnitFrequency, value float64) (*UnitFrequencyConversion, error) {
	// Create the url.
	path := "/unit/conversion/frequency/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitFrequencyConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetLengthConversion: Convert length units.
// Convert a length unit value to another length unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of length units.
//   - `outputUnit`: The valid types of length units.
//   - `value`
func (s *UnitService) GetLengthConversion(inputUnit UnitLength, outputUnit UnitLength, value float64) (*UnitLengthConversion, error) {
	// Create the url.
	path := "/unit/conversion/length/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitLengthConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetMassConversion: Convert mass units.
// Convert a mass unit value to another mass unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of mass units.
//   - `outputUnit`: The valid types of mass units.
//   - `value`
func (s *UnitService) GetMassConversion(inputUnit UnitMas, outputUnit UnitMas, value float64) (*UnitMassConversion, error) {
	// Create the url.
	path := "/unit/conversion/mass/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitMassConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetPowerConversion: Convert power units.
// Convert a power unit value to another power unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of power units.
//   - `outputUnit`: The valid types of power units.
//   - `value`
func (s *UnitService) GetPowerConversion(inputUnit UnitPower, outputUnit UnitPower, value float64) (*UnitPowerConversion, error) {
	// Create the url.
	path := "/unit/conversion/power/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitPowerConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetPressureConversion: Convert pressure units.
// Convert a pressure unit value to another pressure unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of pressure units.
//   - `outputUnit`: The valid types of pressure units.
//   - `value`
func (s *UnitService) GetPressureConversion(inputUnit UnitPressure, outputUnit UnitPressure, value float64) (*UnitPressureConversion, error) {
	// Create the url.
	path := "/unit/conversion/pressure/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitPressureConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetTemperatureConversion: Convert temperature units.
// Convert a temperature unit value to another temperature unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of temperature units.
//   - `outputUnit`: The valid types of temperature units.
//   - `value`
func (s *UnitService) GetTemperatureConversion(inputUnit UnitTemperature, outputUnit UnitTemperature, value float64) (*UnitTemperatureConversion, error) {
	// Create the url.
	path := "/unit/conversion/temperature/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitTemperatureConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetTorqueConversion: Convert torque units.
// Convert a torque unit value to another torque unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of torque units.
//   - `outputUnit`: The valid types of torque units.
//   - `value`
func (s *UnitService) GetTorqueConversion(inputUnit UnitTorque, outputUnit UnitTorque, value float64) (*UnitTorqueConversion, error) {
	// Create the url.
	path := "/unit/conversion/torque/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitTorqueConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetVolumeConversion: Convert volume units.
// Convert a volume unit value to another volume unit value. This is a nice endpoint to use for helper functions.
//
// Parameters
//
//   - `inputUnit`: The valid types of volume units.
//   - `outputUnit`: The valid types of volume units.
//   - `value`
func (s *UnitService) GetVolumeConversion(inputUnit UnitVolume, outputUnit UnitVolume, value float64) (*UnitVolumeConversion, error) {
	// Create the url.
	path := "/unit/conversion/volume/{{.input_unit}}/{{.output_unit}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"input_unit":  string(inputUnit),
		"output_unit": string(outputUnit),
		"value":       fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UnitVolumeConversion
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetSelf: Get your user.
// Get the user information for the authenticated user.
// Alternatively, you can also use the `/users/me` endpoint.
func (s *UserService) GetSelf() (*User, error) {
	// Create the url.
	path := "/user"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded User
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateSelf: Update your user.
// This endpoint requires authentication by any KittyCAD user. It updates information about the authenticated user.
//
// Parameters
//
//   - `body`: The user-modifiable parts of a User.
func (s *UserService) UpdateSelf(body UpdateUser) (*User, error) {
	// Create the url.
	path := "/user"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded User
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteSelf: Delete your user.
// This endpoint requires authentication by any KittyCAD user. It deletes the authenticated user from KittyCAD's database.
// This call will only succeed if all invoices associated with the user have been paid in full and there is no outstanding balance.
func (s *UserService) DeleteSelf() error {
	// Create the url.
	path := "/user"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// UserList: List API calls for your user.
// This endpoint requires authentication by any KittyCAD user. It returns the API calls for the authenticated user.
// The API calls are returned in order of creation, with the most recently created API calls first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *APICallService) UserList(limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/user/api-calls"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetForUser: Get an API call for a user.
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested API call for the user.
//
// Parameters
//
//   - `id`
func (s *APICallService) GetForUser(id string) (*APICallWithPrice, error) {
	// Create the url.
	path := "/user/api-calls/{{.id}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPrice
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListForUser: List API tokens for your user.
// This endpoint requires authentication by any KittyCAD user. It returns the API tokens for the authenticated user.
// The API tokens are returned in order of creation, with the most recently created API tokens first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *APITokenService) ListForUser(limit int, pageToken string, sortBy CreatedAtSortMode) (*APITokenResultsPage, error) {
	// Create the url.
	path := "/user/api-tokens"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APITokenResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateForUser: Create a new API token for your user.
// This endpoint requires authentication by any KittyCAD user. It creates a new API token for the authenticated user.
func (s *APITokenService) CreateForUser() (*APIToken, error) {
	// Create the url.
	path := "/user/api-tokens"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APIToken
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetForUser: Get an API token for your user.
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested API token for the user.
//
// Parameters
//
//   - `token`
func (s *APITokenService) GetForUser(token UUID) (*APIToken, error) {
	// Create the url.
	path := "/user/api-tokens/{{.token}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": token.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APIToken
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteForUser: Delete an API token for your user.
// This endpoint requires authentication by any KittyCAD user. It deletes the requested API token for the user.
// This endpoint does not actually delete the API token from the database. It merely marks the token as invalid. We still want to keep the token in the database for historical purposes.
//
// Parameters
//
//   - `token`
func (s *APITokenService) DeleteForUser(token UUID) error {
	// Create the url.
	path := "/user/api-tokens/{{.token}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": token.String(),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetSelfExtended: Get extended information about your user.
// Get the user information for the authenticated user.
// Alternatively, you can also use the `/users-extended/me` endpoint.
func (s *UserService) GetSelfExtended() (*ExtendedUser, error) {
	// Create the url.
	path := "/user/extended"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ExtendedUser
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetFrontHashSelf: Get your user's front verification hash.
// This info is sent to front when initialing the front chat, it prevents impersonations using js hacks in the browser
func (s *UserService) GetFrontHashSelf() (*string, error) {
	// Create the url.
	path := "/user/front-hash"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded string
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetOnboardingSelf: Get your user's onboarding status.
// Checks key part of their api usage to determine their onboarding progress
func (s *UserService) GetOnboardingSelf() (*Onboarding, error) {
	// Create the url.
	path := "/user/onboarding"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Onboarding
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetInformationForUser: Get payment info about your user.
// This includes billing address, phone, and name.
// This endpoint requires authentication by any KittyCAD user. It gets the payment information for the authenticated user.
func (s *PaymentService) GetInformationForUser() (*Customer, error) {
	// Create the url.
	path := "/user/payment"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Customer
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateInformationForUser: Create payment info for your user.
// This includes billing address, phone, and name.
// This endpoint requires authentication by any KittyCAD user. It creates the payment information for the authenticated user.
//
// Parameters
//
//   - `body`: The billing information for payments.
func (s *PaymentService) CreateInformationForUser(body BillingInfo) (*Customer, error) {
	// Create the url.
	path := "/user/payment"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Customer
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// UpdateInformationForUser: Update payment info for your user.
// This includes billing address, phone, and name.
// This endpoint requires authentication by any KittyCAD user. It updates the payment information for the authenticated user.
//
// Parameters
//
//   - `body`: The billing information for payments.
func (s *PaymentService) UpdateInformationForUser(body BillingInfo) (*Customer, error) {
	// Create the url.
	path := "/user/payment"
	uri := resolveRelative(s.client.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add our headers.
	req.Header.Add("Content-Type", "application/json")

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Customer
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteInformationForUser: Delete payment info for your user.
// This includes billing address, phone, and name.
// This endpoint requires authentication by any KittyCAD user. It deletes the payment information for the authenticated user.
func (s *PaymentService) DeleteInformationForUser() error {
	// Create the url.
	path := "/user/payment"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetBalanceForUser: Get balance for your user.
// This endpoint requires authentication by any KittyCAD user. It gets the balance information for the authenticated user.
func (s *PaymentService) GetBalanceForUser() (*CustomerBalance, error) {
	// Create the url.
	path := "/user/payment/balance"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded CustomerBalance
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateIntentForUser: Create a payment intent for your user.
// This endpoint requires authentication by any KittyCAD user. It creates a new payment intent for the authenticated user.
func (s *PaymentService) CreateIntentForUser() (*PaymentIntent, error) {
	// Create the url.
	path := "/user/payment/intent"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded PaymentIntent
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListInvoicesForUser: List invoices for your user.
// This endpoint requires authentication by any KittyCAD user. It lists invoices for the authenticated user.
func (s *PaymentService) ListInvoicesForUser() (*[]Invoice, error) {
	// Create the url.
	path := "/user/payment/invoices"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []Invoice
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListMethodsForUser: List payment methods for your user.
// This endpoint requires authentication by any KittyCAD user. It lists payment methods for the authenticated user.
func (s *PaymentService) ListMethodsForUser() (*[]PaymentMethod, error) {
	// Create the url.
	path := "/user/payment/methods"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded []PaymentMethod
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// DeleteMethodForUser: Delete a payment method for your user.
// This endpoint requires authentication by any KittyCAD user. It deletes the specified payment method for the authenticated user.
//
// Parameters
//
//   - `id`
func (s *PaymentService) DeleteMethodForUser(id string) error {
	// Create the url.
	path := "/user/payment/methods/{{.id}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// ValidateCustomerTaxInformationForUser: Validate a customer's information is correct and valid for automatic tax.
// This endpoint requires authentication by any KittyCAD user. It will return an error if the customer's information is not valid for automatic tax. Otherwise, it will return an empty successful response.
func (s *PaymentService) ValidateCustomerTaxInformationForUser() error {
	// Create the url.
	path := "/user/payment/tax"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	// Return.
	return nil

}

// GetSessionFor: Get a session for your user.
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested API token for the user.
//
// Parameters
//
//   - `token`
func (s *UserService) GetSessionFor(token UUID) (*Session, error) {
	// Create the url.
	path := "/user/session/{{.token}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": token.String(),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded Session
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// List: List users.
// This endpoint required authentication by a KittyCAD employee. The users are returned in order of creation, with the most recently created users first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *UserService) List(limit int, pageToken string, sortBy CreatedAtSortMode) (*UserResultsPage, error) {
	// Create the url.
	path := "/users"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListExtended: List users with extended information.
// This endpoint required authentication by a KittyCAD employee. The users are returned in order of creation, with the most recently created users first.
//
// Parameters
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *UserService) ListExtended(limit int, pageToken string, sortBy CreatedAtSortMode) (*ExtendedUserResultsPage, error) {
	// Create the url.
	path := "/users-extended"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ExtendedUserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// GetExtended: Get extended information about a user.
// To get information about yourself, use `/users-extended/me` as the endpoint. By doing so you will get the user information for the authenticated user.
// Alternatively, to get information about the authenticated user, use `/user/extended` endpoint.
// To get information about any KittyCAD user, you must be a KittyCAD employee.
//
// Parameters
//
//   - `id`
func (s *UserService) GetExtended(id string) (*ExtendedUser, error) {
	// Create the url.
	path := "/users-extended/{{.id}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded ExtendedUser
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// Get: Get a user.
// To get information about yourself, use `/users/me` as the endpoint. By doing so you will get the user information for the authenticated user.
// Alternatively, to get information about the authenticated user, use `/user` endpoint.
// To get information about any KittyCAD user, you must be a KittyCAD employee.
//
// Parameters
//
//   - `id`
func (s *UserService) Get(id string) (*User, error) {
	// Create the url.
	path := "/users/{{.id}}"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded User
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// ListForUser: List API calls for a user.
// This endpoint requires authentication by any KittyCAD user. It returns the API calls for the authenticated user if "me" is passed as the user id.
// Alternatively, you can use the `/user/api-calls` endpoint to get the API calls for your user.
// If the authenticated user is a KittyCAD employee, then the API calls are returned for the user specified by the user id.
// The API calls are returned in order of creation, with the most recently created API calls first.
//
// Parameters
//
//   - `id`
//
//   - `limit`
//
//   - `pageToken`
//
//   - `sortBy`: Supported set of sort modes for scanning by created_at only.
//
//     Currently, we only support scanning in ascending order.
func (s *APICallService) ListForUser(id string, limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/users/{{.id}}/api-calls"
	uri := resolveRelative(s.client.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":         id,
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var decoded APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &decoded, nil

}

// CreateTerm: Create a terminal.
// Attach to a docker container to create an interactive terminal.
func (s *ExecutorService) CreateTerm() (*websocket.Conn, error) {
	// Create the url.
	path := "/ws/executor/term"
	uri := resolveRelative(s.client.server, path)

	headers := http.Header{}
	headers["Authorization"] = []string{fmt.Sprintf("Bearer %s", s.client.token)}

	conn, _, err := websocket.DefaultDialer.Dial(strings.ReplaceAll(uri, "https://", "wss://"), headers)
	if err != nil {
		return nil, err
	}

	return conn, nil
}

// CommandsWs: Open a websocket which accepts modeling commands.
// Pass those commands to the engine via websocket, and pass responses back to the client. Basically, this is a websocket proxy between the frontend/client and the engine.
//
// Parameters
//
//   - `fps`
//   - `unlockedFramerate`
//   - `videoResHeight`
//   - `videoResWidth`
//   - `webrtc`
func (s *ModelingService) CommandsWs(fps int, unlockedFramerate bool, videoResHeight int, videoResWidth int, webrtc bool) (*websocket.Conn, error) {
	// Create the url.
	path := "/ws/modeling/commands"
	uri := resolveRelative(s.client.server, path)

	headers := http.Header{}
	headers["Authorization"] = []string{fmt.Sprintf("Bearer %s", s.client.token)}

	conn, _, err := websocket.DefaultDialer.Dial(strings.ReplaceAll(uri, "https://", "wss://"), headers)
	if err != nil {
		return nil, err
	}

	return conn, nil
}
