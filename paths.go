// Code generated by `generate`. DO NOT EDIT.

package kittycad

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"

	"github.com/google/uuid"
)

// GetSchema: Get OpenAPI schema.
func (s *MetaService) GetSchema() (*ResponseGetSchema, error) {
	// Create the url.
	path := "/"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ResponseGetSchema
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Getdata: Get the metadata about our currently running server.
//
// This includes information on any of our other distributed systems it is connected to.
// You must be a KittyCAD employee to perform this request.
func (s *MetaService) Getdata() (*Metadata, error) {
	// Create the url.
	path := "/_meta/info"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Metadata
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GetMetrics: Get API call metrics.
//
// This endpoint requires authentication by a KittyCAD employee. The API calls are grouped by the parameter passed.
//
// Parameters:
//	- `groupBy`: What field to group the metrics by.
func (s *APICallService) GetMetrics(groupBy APICallQueryGroupBy) (*[]APICallQueryGroup, error) {
	// Create the url.
	path := "/api-call-metrics"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"group_by": string(groupBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body []APICallQueryGroup
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List API calls.
//
// This endpoint requires authentication by a KittyCAD employee. The API calls are returned in order of creation, with the most recently created API calls first.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retrieve the subsequent page
//	- `sortBy`
func (s *APICallService) List(limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/api-calls"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get details of an API call.
//
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested API call for the user.
// If the user is not authenticated to view the specified API call, then it is not returned.
// Only KittyCAD employees can view API calls for other users.
//
// Parameters:
//	- `id`: The ID of the API call.
func (s *APICallService) Get(id string) (*APICallWithPrice, error) {
	// Create the url.
	path := "/api-calls/{{.id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body APICallWithPrice
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GithubCallback: Listen for callbacks to GitHub app authentication.
//
// This is different than OAuth 2.0 authentication for users. This endpoint grants access for KittyCAD to access user's repos.
// The user doesn't need KittyCAD OAuth authorization for this endpoint, this is purely for the GitHub permissions to access repos.
func (s *AppService) GithubCallback(j *interface{}) error {
	// Create the url.
	path := "/apps/github/callback"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("GET", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// GithubConsent: Get the consent URL for GitHub app authentication.
//
// This is different than OAuth 2.0 authentication for users. This endpoint grants access for KittyCAD to access user's repos.
// The user doesn't need KittyCAD OAuth authorization for this endpoint, this is purely for the GitHub permissions to access repos.
func (s *AppService) GithubConsent() (*AppClientInfo, error) {
	// Create the url.
	path := "/apps/github/consent"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body AppClientInfo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAsyncOperations: List async operations.
//
// For async file conversion operations, this endpoint does not return the contents of converted files (`output`). To get the contents use the `/async/operations/{id}` endpoint.
// This endpoint requires authentication by a KittyCAD employee.
//
// To iterate over all pages, use the `ListAsyncOperationsAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retrieve the subsequent page
//	- `sortBy`
//	- `status`: The status to filter by.
func (s *APICallService) ListAsyncOperations(limit int, pageToken string, sortBy CreatedAtSortMode, status APICallStatus) (*AsyncAPICallResultsPage, error) {
	// Create the url.
	path := "/async/operations"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
		"status":     string(status),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body AsyncAPICallResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GetAsyncOperation: Get an async operation.
//
// Get the status and output of an async operation.
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested async operation for the user.
// If the user is not authenticated to view the specified async operation, then it is not returned.
// Only KittyCAD employees with the proper access can view async operations for other users.
//
// Parameters:
//	- `id`: The ID of the async operation.
func (s *APICallService) GetAsyncOperation(id string) (*AsyncAPICallOutput, error) {
	// Create the url.
	path := "/async/operations/{{.id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body AsyncAPICallOutput
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// AuthEmail: Create an email verification request for a user.
func (s *HiddenService) AuthEmail(j *EmailAuthenticationForm) (*VerificationToken, error) {
	// Create the url.
	path := "/auth/email"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VerificationToken
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// AuthEmailCallback: Listen for callbacks for email verification for users.
//
// Parameters:
//	- `callbackUrl`: The URL to redirect back to after we have authenticated.
//	- `email`: The user's email.
//	- `token`: The verification token.
func (s *HiddenService) AuthEmailCallback(callbackUrl url.URL, email string, token string) error {
	// Create the url.
	path := "/auth/email/callback"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"callback_url": string(callbackUrl),
		"email":        email,
		"token":        token,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// CreateConversion: Convert CAD file.
//
// Convert a CAD file from one format to another. If the file being converted is larger than 25MB, it will be performed asynchronously.
// If the conversion is performed synchronously, the contents of the converted file (`output`) will be returned as a base64 encoded string.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters:
//	- `outputFormat`: The format the file should be converted to.
//	- `srcFormat`: The format of the file to convert.
func (s *FileService) CreateConversion(outputFormat FileOutputFormat, srcFormat FileSourceFormat, b io.Reader) (*FileConversion, error) {
	// Create the url.
	path := "/file/conversion/{{.src_format}}/{{.output_format}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_format": string(outputFormat),
		"src_format":    string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FileConversion
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GetConversion: Get a file conversion.
//
// Get the status and output of an async file conversion.
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested file conversion for the user.
// If the user is not authenticated to view the specified file conversion, then it is not returned.
// Only KittyCAD employees with the proper access can view file conversions for other users.
//
// Parameters:
//	- `id`: The ID of the async operation.
func (s *FileService) GetConversion(id string) (*AsyncAPICallOutput, error) {
	// Create the url.
	path := "/file/conversions/{{.id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body AsyncAPICallOutput
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// CreateDensity: Get CAD file density.
//
// Get the density of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters:
//	- `materialMass`: The material mass.
//	- `srcFormat`: The format of the file.
func (s *FileService) CreateDensity(materialMass float64, srcFormat FileSourceFormat, b io.Reader) (*FileDensity, error) {
	// Create the url.
	path := "/file/density"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"material_mass": fmt.Sprintf("%f", materialMass),
		"src_format":    string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FileDensity
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// CreateExecution: Execute a KittyCAD program in a specific language.
//
// Parameters:
//	- `lang`: The language of the code.
//	- `output`: The output file we want to get the contents for (the paths are relative to where in litterbox it is being run). You can denote more than one file with a comma separated list of string paths.
func (s *FileService) CreateExecution(lang CodeLanguage, output string, b io.Reader) (*CodeOutput, error) {
	// Create the url.
	path := "/file/execute/{{.lang}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"lang":   string(lang),
		"output": output,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body CodeOutput
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// CreateMass: Get CAD file mass.
//
// Get the mass of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters:
//	- `materialDensity`: The material density.
//	- `srcFormat`: The format of the file.
func (s *FileService) CreateMass(materialDensity float64, srcFormat FileSourceFormat, b io.Reader) (*FileMass, error) {
	// Create the url.
	path := "/file/mass"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"material_density": fmt.Sprintf("%f", materialDensity),
		"src_format":       string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FileMass
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// CreateVolume: Get CAD file volume.
//
// Get the volume of an object in a CAD file. If the file is larger than 25MB, it will be performed asynchronously.
// If the operation is performed asynchronously, the `id` of the operation will be returned. You can use the `id` returned from the request to get status information about the async operation from the `/async/operations/{id}` endpoint.
//
// Parameters:
//	- `srcFormat`: The format of the file.
func (s *FileService) CreateVolume(srcFormat FileSourceFormat, b io.Reader) (*FileVolume, error) {
	// Create the url.
	path := "/file/volume"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"src_format": string(srcFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FileVolume
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Logout: This endpoint removes the session cookie for a user.
//
// This is used in logout scenarios.
func (s *HiddenService) Logout() error {
	// Create the url.
	path := "/logout"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// DeviceAuthRequest: Start an OAuth 2.0 Device Authorization Grant.
//
// This endpoint is designed to be accessed from an *unauthenticated* API client. It generates and records a `device_code` and `user_code` which must be verified and confirmed prior to a token being granted.
func (s *Oauth2Service) DeviceAuthRequest(b io.Reader) (*ResponseDeviceAuthRequest, error) {
	// Create the url.
	path := "/oauth2/device/auth"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ResponseDeviceAuthRequest
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DeviceAuthConfirm: Confirm an OAuth 2.0 Device Authorization Grant.
//
// This endpoint is designed to be accessed by the user agent (browser), not the client requesting the token. So we do not actually return the token here; it will be returned in response to the poll on `/oauth2/device/token`.
func (s *Oauth2Service) DeviceAuthConfirm(j *DeviceAuthVerifyParams) error {
	// Create the url.
	path := "/oauth2/device/confirm"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// DeviceAccessToken: Request a device access token.
//
// This endpoint should be polled by the client until the user code is verified and the grant is confirmed.
func (s *Oauth2Service) DeviceAccessToken(b io.Reader) (*ResponseDeviceAccessToken, error) {
	// Create the url.
	path := "/oauth2/device/token"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ResponseDeviceAccessToken
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DeviceAuthVerify: Verify an OAuth 2.0 Device Authorization Grant.
//
// This endpoint should be accessed in a full user agent (e.g., a browser). If the user is not logged in, we redirect them to the login page and use the `callback_url` parameter to get them to the UI verification form upon logging in. If they are logged in, we redirect them to the UI verification form on the website.
//
// Parameters:
//	- `userCode`: The user code.
func (s *Oauth2Service) DeviceAuthVerify(userCode string) error {
	// Create the url.
	path := "/oauth2/device/verify"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"user_code": userCode,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// ProviderCallback: Listen for callbacks for the OAuth 2.0 provider.
//
// Parameters:
//	- `code`: The authorization code.
//	- `provider`: The provider.
//	- `state`: The state that we had passed in through the user consent URL.
func (s *Oauth2Service) ProviderCallback(provider AccountProvider, code string, state string) error {
	// Create the url.
	path := "/oauth2/provider/{{.provider}}/callback"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"code":     code,
		"provider": string(provider),
		"state":    state,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// ProviderConsent: Get the consent URL and other information for the OAuth 2.0 provider.
//
// Parameters:
//	- `callbackUrl`: The URL to redirect back to after we have authenticated.
//	- `provider`: The provider.
func (s *Oauth2Service) ProviderConsent(provider AccountProvider, callbackUrl string) (*OAuth2ClientInfo, error) {
	// Create the url.
	path := "/oauth2/provider/{{.provider}}/consent"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"callback_url": callbackUrl,
		"provider":     string(provider),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body OAuth2ClientInfo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Ping: Return pong.
func (s *MetaService) Ping() (*Pong, error) {
	// Create the url.
	path := "/ping"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Pong
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// CreateConversion: Convert units.
//
// Convert a metric unit value to another metric unit value. This is a nice endpoint to use for helper functions.
//
// Parameters:
//	- `outputFormat`: The output format of the unit.
//	- `srcFormat`: The source format of the unit.
//	- `value`: The initial value.
func (s *UnitService) CreateConversion(outputFormat UnitMetricFormat, srcFormat UnitMetricFormat, value float64) (*UnitConversion, error) {
	// Create the url.
	path := "/unit/conversion/{{.src_format}}/{{.output_format}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"output_format": string(outputFormat),
		"src_format":    string(srcFormat),
		"value":         fmt.Sprintf("%f", value),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body UnitConversion
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GetSelf: Get your user.
//
// Get the user information for the authenticated user.
// Alternatively, you can also use the `/users/me` endpoint.
func (s *UserService) GetSelf() (*User, error) {
	// Create the url.
	path := "/user"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// UpdateSelf: Update your user.
//
// This endpoint requires authentication by any KittyCAD user. It updates information about the authenticated user.
func (s *UserService) UpdateSelf(j *UpdateUser) (*User, error) {
	// Create the url.
	path := "/user"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DeleteSelf: Delete your user.
//
// This endpoint requires authentication by any KittyCAD user. It deletes the authenticated user from KittyCAD's database.
// This call will only succeed if all invoices associated with the user have been paid in full and there is no outstanding balance.
func (s *UserService) DeleteSelf() error {
	// Create the url.
	path := "/user"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// UserList: List API calls for your user.
//
// This endpoint requires authentication by any KittyCAD user. It returns the API calls for the authenticated user.
// The API calls are returned in order of creation, with the most recently created API calls first.
//
// To iterate over all pages, use the `UserListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retrieve the subsequent page
//	- `sortBy`
func (s *APICallService) UserList(limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/user/api-calls"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GetForUser: Get an API call for a user.
//
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested API call for the user.
//
// Parameters:
//	- `id`: The ID of the API call.
func (s *APICallService) GetForUser(id string) (*APICallWithPrice, error) {
	// Create the url.
	path := "/user/api-calls/{{.id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body APICallWithPrice
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListForUser: List API tokens for your user.
//
// This endpoint requires authentication by any KittyCAD user. It returns the API tokens for the authenticated user.
// The API tokens are returned in order of creation, with the most recently created API tokens first.
//
// To iterate over all pages, use the `ListForUserAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retrieve the subsequent page
//	- `sortBy`
func (s *APITokenService) ListForUser(limit int, pageToken string, sortBy CreatedAtSortMode) (*APITokenResultsPage, error) {
	// Create the url.
	path := "/user/api-tokens"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body APITokenResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// CreateForUser: Create a new API token for your user.
//
// This endpoint requires authentication by any KittyCAD user. It creates a new API token for the authenticated user.
func (s *APITokenService) CreateForUser() (*APIToken, error) {
	// Create the url.
	path := "/user/api-tokens"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body APIToken
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GetForUser: Get an API token for your user.
//
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested API token for the user.
//
// Parameters:
//	- `token`: The API token.
func (s *APITokenService) GetForUser(token uuid.UUID) (*APIToken, error) {
	// Create the url.
	path := "/user/api-tokens/{{.token}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": string(token),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body APIToken
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DeleteForUser: Delete an API token for your user.
//
// This endpoint requires authentication by any KittyCAD user. It deletes the requested API token for the user.
// This endpoint does not actually delete the API token from the database. It merely marks the token as invalid. We still want to keep the token in the database for historical purposes.
//
// Parameters:
//	- `token`: The API token.
func (s *APITokenService) DeleteForUser(token uuid.UUID) error {
	// Create the url.
	path := "/user/api-tokens/{{.token}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": string(token),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// GetSelfExtended: Get extended information about your user.
//
// Get the user information for the authenticated user.
// Alternatively, you can also use the `/users-extended/me` endpoint.
func (s *UserService) GetSelfExtended() (*ExtendedUser, error) {
	// Create the url.
	path := "/user/extended"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ExtendedUser
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GetConversionForUser: Get a file conversion for your user.
//
// Get the status and output of an async file conversion. If completed, the contents of the converted file (`output`) will be returned as a base64 encoded string.
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested file conversion for the user.
//
// Parameters:
//	- `id`: The ID of the async operation.
func (s *FileService) GetConversionForUser(id string) (*AsyncAPICallOutput, error) {
	// Create the url.
	path := "/user/file/conversions/{{.id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body AsyncAPICallOutput
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GetInformationForUser: Get payment info about your user.
//
// This includes billing address, phone, and name.
// This endpoint requires authentication by any KittyCAD user. It gets the payment information for the authenticated user.
func (s *PaymentService) GetInformationForUser() (*Customer, error) {
	// Create the url.
	path := "/user/payment"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Customer
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// CreateInformationForUser: Create payment info for your user.
//
// This includes billing address, phone, and name.
// This endpoint requires authentication by any KittyCAD user. It creates the payment information for the authenticated user.
func (s *PaymentService) CreateInformationForUser(j *BillingInfo) (*Customer, error) {
	// Create the url.
	path := "/user/payment"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Customer
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// UpdateInformationForUser: Update payment info for your user.
//
// This includes billing address, phone, and name.
// This endpoint requires authentication by any KittyCAD user. It updates the payment information for the authenticated user.
func (s *PaymentService) UpdateInformationForUser(j *BillingInfo) (*Customer, error) {
	// Create the url.
	path := "/user/payment"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Customer
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DeleteInformationForUser: Delete payment info for your user.
//
// This includes billing address, phone, and name.
// This endpoint requires authentication by any KittyCAD user. It deletes the payment information for the authenticated user.
func (s *PaymentService) DeleteInformationForUser() error {
	// Create the url.
	path := "/user/payment"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// GetBalanceForUser: Get balance for your user.
//
// This endpoint requires authentication by any KittyCAD user. It gets the balance information for the authenticated user.
func (s *PaymentService) GetBalanceForUser() (*CustomerBalance, error) {
	// Create the url.
	path := "/user/payment/balance"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body CustomerBalance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// CreateIntentForUser: Create a payment intent for your user.
//
// This endpoint requires authentication by any KittyCAD user. It creates a new payment intent for the authenticated user.
func (s *PaymentService) CreateIntentForUser() (*PaymentIntent, error) {
	// Create the url.
	path := "/user/payment/intent"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body PaymentIntent
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListInvoicesForUser: List invoices for your user.
//
// This endpoint requires authentication by any KittyCAD user. It lists invoices for the authenticated user.
func (s *PaymentService) ListInvoicesForUser() (*[]Invoice, error) {
	// Create the url.
	path := "/user/payment/invoices"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body []Invoice
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListMethodsForUser: List payment methods for your user.
//
// This endpoint requires authentication by any KittyCAD user. It lists payment methods for the authenticated user.
func (s *PaymentService) ListMethodsForUser() (*[]PaymentMethod, error) {
	// Create the url.
	path := "/user/payment/methods"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body []PaymentMethod
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DeleteMethodForUser: Delete a payment method for your user.
//
// This endpoint requires authentication by any KittyCAD user. It deletes the specified payment method for the authenticated user.
//
// Parameters:
//	- `id`: The ID of the payment method.
func (s *PaymentService) DeleteMethodForUser(id string) error {
	// Create the url.
	path := "/user/payment/methods/{{.id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// GetForUser: Get a session for your user.
//
// This endpoint requires authentication by any KittyCAD user. It returns details of the requested API token for the user.
//
// Parameters:
//	- `token`: The API token.
func (s *SessionService) GetForUser(token uuid.UUID) (*Session, error) {
	// Create the url.
	path := "/user/session/{{.token}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"token": string(token),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Session
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List users.
//
// This endpoint required authentication by a KittyCAD employee. The users are returned in order of creation, with the most recently created users first.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retrieve the subsequent page
//	- `sortBy`
func (s *UserService) List(limit int, pageToken string, sortBy CreatedAtSortMode) (*UserResultsPage, error) {
	// Create the url.
	path := "/users"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListExtended: List users with extended information.
//
// This endpoint required authentication by a KittyCAD employee. The users are returned in order of creation, with the most recently created users first.
//
// To iterate over all pages, use the `ListExtendedAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retrieve the subsequent page
//	- `sortBy`
func (s *UserService) ListExtended(limit int, pageToken string, sortBy CreatedAtSortMode) (*ExtendedUserResultsPage, error) {
	// Create the url.
	path := "/users-extended"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ExtendedUserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GetExtended: Get extended information about a user.
//
// To get information about yourself, use `/users-extended/me` as the endpoint. By doing so you will get the user information for the authenticated user.
// Alternatively, to get information about the authenticated user, use `/user/extended` endpoint.
// To get information about any KittyCAD user, you must be a KittyCAD employee.
//
// Parameters:
//	- `id`: The user ID.
func (s *UserService) GetExtended(id string) (*ExtendedUser, error) {
	// Create the url.
	path := "/users-extended/{{.id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ExtendedUser
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get a user.
//
// To get information about yourself, use `/users/me` as the endpoint. By doing so you will get the user information for the authenticated user.
// Alternatively, to get information about the authenticated user, use `/user` endpoint.
// To get information about any KittyCAD user, you must be a KittyCAD employee.
//
// Parameters:
//	- `id`: The user ID.
func (s *UserService) Get(id string) (*User, error) {
	// Create the url.
	path := "/users/{{.id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListForUser: List API calls for a user.
//
// This endpoint requires authentication by any KittyCAD user. It returns the API calls for the authenticated user if "me" is passed as the user id.
// Alternatively, you can use the `/user/api-calls` endpoint to get the API calls for your user.
// If the authenticated user is a KittyCAD employee, then the API calls are returned for the user specified by the user id.
// The API calls are returned in order of creation, with the most recently created API calls first.
//
// To iterate over all pages, use the `ListForUserAllPages` method, instead.
//
// Parameters:
//	- `id`: The user ID.
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retrieve the subsequent page
//	- `sortBy`
func (s *APICallService) ListForUser(id string, limit int, pageToken string, sortBy CreatedAtSortMode) (*APICallWithPriceResultsPage, error) {
	// Create the url.
	path := "/users/{{.id}}/api-calls"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id":         id,
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body APICallWithPriceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}
