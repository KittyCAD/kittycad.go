// Code generated by `generate`. DO NOT EDIT.

package kittycad

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
)

// StopAsyncConversions: Stop all async conversions
//
// Stop all async conversions that are currently running. This endpoint can only be used by specific KittyCAD employees.
func (s *InternalService) StopAsyncConversions() (*FileConversion, error) {
	// Create the url.
	path := "/_internal/async/conversions/stop"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FileConversion
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// GPUDevices: Get GPU devices
//
// Get information about GPU devices on this server. This is primarily used for debugging. This endpoint can only be used by specific KittyCAD employees.
func (s *InternalService) GPUDevices() (*[]GPUDevice, error) {
	// Create the url.
	path := "/_internal/gpu/devices"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body []GPUDevice
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// InstanceMetadata: Get instance metadata
//
// Get information about this specific API server instance. This is primarily used for debugging.
func (s *MetaService) InstanceMetadata() (*Instance, error) {
	// Create the url.
	path := "/_meta/debug/instance"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// AuthSession: Get auth session
//
// Get information about your API request session. This is primarily used for debugging.
func (s *MetaService) AuthSession() (*AuthSession, error) {
	// Create the url.
	path := "/_meta/debug/session"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body AuthSession
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ConversionStatus: Get a file conversion
//
// Get the status and output of an async file conversion.
//
// Parameters:
//	- `id`: The id of the file conversion.
func (s *FileService) ConversionStatus(id string) (*FileConversion, error) {
	// Create the url.
	path := "/file/conversion/{{.id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FileConversion
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// PostConversion: Convert CAD file
//
// Convert a CAD file from one format to another. If the file being converted is larger than 30MB, it will be performed asynchronously.
//
// Parameters:
//	- `outputFormat`: The format the file should be converted to.
//	- `sourceFormat`: The format of the file to convert.
func (s *FileService) PostConversion(sourceFormat ValidSourceFileFormat, outputFormat ValidOutputFileFormat, b io.Reader) (*FileConversion, error) {
	// Create the url.
	path := "/file/conversion/{{.sourceFormat}}/{{.outputFormat}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"outputFormat": string(outputFormat),
		"sourceFormat": string(sourceFormat),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FileConversion
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Ping: Ping
//
// Simple ping to the server.
func (s *MetaService) Ping() (*PongMessage, error) {
	// Create the url.
	path := "/ping"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body PongMessage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}
